[{"categories":["Algorithms"],"content":"Vowel Spellchecker  Given a wordlist, we want to implement a spellchecker that converts a query word into a correct word.\n  For a given query word, the spell checker handles two categories of spelling mistakes:\n Capitalization: If the query matches a word in the wordlist, then the query word is returned with the same case as the case in the wordlist. Vowel Errors: If after replacing the vowels 'aeiou' of the query word with any vowelindiviually, it matches a word in the wordlist, then the query word is return ted with the same case as the case in the wordlist.    In addition, the spell checker operates under the following precedence rules:\n when the query exactly matched a word in the wordlist, return it when the query matches a word up to capitalization, return the first. when the query matches a word up to vowel errors, return the first otherwise, return the empty string   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  def checker(words: List[str], queries: List[str]) -\u003e List[str]: vowels = re.compile(r'[aeiou]') def check(query): if query in s: return query lower = query.lower() c = vowels.sub('?', lower) candidates = d[c] if not candidates: return '' for word in candidates: if word.lower() == query.lower(): return word return candidates[0] s = set(words) d = defaultdict(list) for word in words: d[vowels.sub('?', word.lower())].append(word) return [check(query) for query in queries]   3Sum with Multiplicity  Given an integer array arr, and an integer target, return the number of tuples i, j, k such that i \u003c j \u003c k and arr[i] + arr[j] + arr[k] == target. As the answer can be very large, return it modulo 10**9 + 7.\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14  def three_sum(arr: List[int], target:int) -\u003e int: MOD = 10 ** 9 + 7 counter = Counter(arr) result = 0 for i, j in combinations(sorted(counter.keys()), 2): k = target - i - j if i \u003c j \u003c k: result += counter[i] * counter[j] * counter[k] for i in counter: if i * 3 == target: result += comb(counter[i], 3) else: result += comb(counter[i], 2) * counter[target - i*2] return result % MOD   Advantage Shuffle  Given two arrays nums1 and nums2 of equal size, the advantage of nums1 with respect to nums2 is the number of indices i for which nums[i] \u003e nums2[i].\n  Return any permutation of nums1 that maximizes its advantage with respect to nums2.\n 1 2 3 4 5 6 7 8  def advantage_shuffle(nums1: List[int], nums2: List[int]) -\u003e List[int]: B = sorted((x, i) for i, x in enumerate(nums2)) A = Deque(sorted(nums1)) result = [0 for _ in nums1] while B: x, i = B.pop() result[i] = A.pop() if A[-1] \u003e x else A.popleft() return result   Pacific Atlantic Water Flow  Given an m x n integer matrix heights representing the height of each unit cell in a continent. The Pacific ocean touches the continent’s left and top edges, and the Atlantic ocean touches the continent’s right and bottom edges.\n  Water can only flow in four directions: up, down, left, and right. Water flows from a cell to an adjacent one with an equal or lower height.\n  Return a list of grid coordinates where water can flow to both the Pacific and Atlantic oceans.\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  def pacific_atlantic(heights: List[List[int]) -\u003e List[List[int]]: DIR = ((-1,0), (0,1), (1,0),(0,-1)) m, n = len(heights), len(heights[0]) def flow(ocean): queue = Deque(ocean) while queue: i, j = queue.popleft() h = heights[i][j] for di, dj in DIR: x, y = i+di, j+dj if 0 \u003c= x \u003c m and 0 \u003c= y \u003c n and (x, y) not in ocean and heights[x][y] \u003e= h: ocean.add((x, y)) queue.append((x, y)) return ocean p = {(i, 0) for i in range(m)} | {(0, j) for j in range(n)} a = {(i, n-1) for i in range(m)} | {(m-1, j) for j in range(n)} return [[i, j] for i, j in flow(p) \u0026 flow(a)]   Word Subsets  Given two array words1 and words2 of words. Each is a string of lowercase letters.\n  Now, say that word b is a subset of word a if every letter in b occurs in a, including multiplicity. For example, \"wrr\" is a subset of \"warrior\", but is not a subset of \"world\".\n  Now say a word a from words1 is universal if for every b in words2, b is a subset of a.\n  Return a list of all universal words in words1. You can return the words in any order.\n 1 2 3  def word_subsets(words1: List[str], words2: List[str]) -\u003e List[str]: pattern = reduce(lambda a, x: a | Counter(x), words2, Counter()) return [word for word in words1 if not (pattern - Counter(word))]   Palindromic Substrings  Given a string s, return the number of palindromic substring in it.\n 1 2 3 4 5 6 7 8 9 10  def count_palindromic(s: str) -\u003e int: n = len(s) result = 0 for i in range(n): for l, r in ((i, i), (i+1)): while 0 \u003c= l and r \u003c n and s[l] == s[i]: result += 1 l, r = l-1, r+1 return result   Reconstruct Original Digits from English  Given a string s containing an out-of-order English representation of digits 0-9, return the digits in ascending order.\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  def original_digits(s: str) -\u003e str: # zero: {e:1, o:1, r:1, z:1} # one: {o:1, n:1, e:1} # two: {t:1, w:1, o:1} # three: {e:2, h:1, r:1, t:1} # four: {f:1, o:1, r:1, u:1} # five: {e:1, f:1, i:1, v:1} # six: {i:1, s:1, x:1} # seven: {e:2, n:1, s:1, v:1} # eight: {e:1, g:1, h:1, i:1, t:1} # nine: {e:1, i:1, n:2} c = Counter(s) digits = ( c['z'], # 0, [z]ero c['o'] - c['z'] - c['w'] - c['u'], # 1, [o]ne, zer[o], tw[o], f[o]ur c['w'], # 2, t[w]o c['r'] - c['u'], # th[r]ee, fou[r] c['f'] - c['u'], # [f]ive, [f]our c['x'], # 6, si[x] c['s'] - c['x'], # 7 [s]even, [s]ix c['g'], # 8, ei[g]ht c['i'] - c['x'] - c['g'] - (c['f'] - c['u']), # 9, n[i]ne, s[i]x, e[i]ght, f[i]ve ) return ''.join(str(i)*c for i, c in enumerate(digits))   ","description":"","tags":null,"title":"2021 March Week 4","uri":"/algorithms/challege/2021-march-week-4/"},{"categories":["Algorithms"],"content":"Encode and Decode TinyURL 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  class TinyUrl: CODE_LIST = string.ascii_lowercase + string.digits NUM_OF_CODE = 5 BASE_URL = 'http://tinyurl.com' def __init__(self): self._long2short = {} self._short2long = {} def encode(long_url: str) -\u003e str: while long_url not in self._long2short: code = ''.join(random.choices(TinyUrl.CODE_LIST, k = TinyUrl.NUM_OF_CODE)) if code not in self._short2long: self._short2long[code] = long_url self._long2short[long_url] = code return f'{TinyUrlBASE_URL}/{self._long2short[long_url]}' def decode(short_url: str) -\u003e str: return self._short2long[short_url[-TinyUrl.NUM_OF_CODE:]]   Best Time to Buy and Seel Stock with Transaction Fee  Given an array prices where prices[i] is the price of a given stock on the i-th day, and an integer fee representing a transaction fee.\n  Find the maximum profit you can achieve. You may complete as many transactions as you like, but you need to pay the transaction fee for each transaction. You must sell the stock before you buy agin.\n 1 2 3 4 5 6  def max_profit(prices: List[int], fee: int) -\u003e int: cash, hold = 0, -prices[0] for price in prices: cash = max(cash, hold + price - fee) hold = max(hold, cash - price) return cash   Generate Random Point in a Circle  Given the radius and the position of the center of a circle, implement the function randPoint which generates a uniform random point inside the circle.\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  class RandomPointInCircle: def __init__(self, radius, x_center, y_center): self._r = radius self._x = x_center self._y = y_center def rand_point(self): theta = math.pi * 2 * random.random() r = sqrt(random.random()) * self._r return [self._x + r * math.cos(theta), self._y + r * math.sin(theta)] def rand_point_square(self): while True: x, y = random.random() * 2 - 1, random.random() * 2 - 1 if x**2 + y**2 \u003c 1: return [self._x + x * self._r, self._y + y * self._r]   Wiggle Subsequence  A wiggle sequence is a sequence where the differences between successive numbers strictly alternate between positive and negative.\n  Given an integer array nums, return the length of the longest wiggle subsequence** of nums.\n 1 2 3 4 5 6 7 8  def longest_wiggle_subsequence(nums: List[int]) -\u003e int: positive = negative = 1 for i in range(1, len(nums)): if nums[i] \u003e nums[i-1]: positive = max(positive, negative + 1) elif nums[i] \u003c nums[i-1]: negative = max(negative, positive + 1) return max(positive, negative)   Keys and Rooms  There are N rooms and you start in room 0. Each room has a distinct number 0, 1, 2, ..., N-1, and each room may have some keys to access the next room.\n  Return true if and only if you can enter every room. The room 0 is open.\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  def can_visit_all_rooms(rooms: List[List[int]]) -\u003e bool: keys, seen = deque(rooms[0]), {0} | set(rooms[0]) while queue: key = keys.popleft() for k in room[key]: if k not in seen: seen.add(k) keys.append(k) return len(seen) == len(rooms) def can_visit_all_rooms(rooms: List[List[int]]) -\u003e bool: keys, seen = set(rooms[0]), {0} | set(rooms[0]) while keys: keys = {k for key in keys for k in rooms[key]} - seen seen |= keys return len(seen) == len(rooms)   Design Underground System  An underground railway system is keeping track of customer travel times between different stations. They are using this data to calculate the average time it takes to travel from one station to another.\n  Implement the UndergroundSystem class:\n void checkIn(int id, string stationName, int t)  A customer with a card id, checks in at station stationName at time t. A customer can only be checked into one place at at time   void checkOut(int id, string stationName, int t)  A customer with a card id, checks out at station stationName at time t.   double getAverageTime(string startStation, string endStation)  Returns the average time it takes to travel from startStation to endStation. Tje to,e ot takes to travel from startStation to endStation may be different from the time from endStation to startStation. There will be at least one customer that has traveled from startStation to endStation before getAverageTime is called.     1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  class UndergroundSystem: def __init__(self): self._checkin = {} self._timer = defaultdict(int) self._counter = defaultdict(int) def checkin(id: int, station: str, t: int) -\u003e None: self._checkin[id] = (station, t) def checkout(id: int, station: str, t: int) -\u003e None: start, begin = self._checkin[id] key = (start, station) self._timer[key] += t - begin self._counter[key] += 1 def get_average_time(start: str, end: str) -\u003e float: key = (start, end) return self._timer[key] / self._counter[key]   Reordered Power of 2  Given an integer n. We reorder the digits in any order such that the leading digit is not zero.\n  Return true if and only if we can do this so that the resulting number is a power of two.\n 1 2 3  def reordered_power_of_2(n: int) -\u003e bool: s = sorted(list(str(n))) return s in (sorted(list(str(1 \u003c\u003c i))) for i in range(31)   ","description":"","tags":null,"title":"2021 March Week 3","uri":"/algorithms/challege/2021-march-week-3/"},{"categories":["Algorithms"],"content":"Remove Palindromic Subsequences  Given a string s consisting only of letters 'a' and 'b'. In a single step you can remove one palindromic subsequence from s.\n  Return the minimum number of steps to make the given string empty.\n 1 2 3 4 5  def remove_palindromic_subsequences(s: str) -\u003e int: # remove all 'a', then 'b' if not s: return 0 return 1 if s == s[::-1] else 2   Add One Row to Tree  Given the root of a binary tree and two integers val and depth, add a row of nodes with value val at the given depth depth.\n  Note that the root is at depth 1.\n 1 2 3 4 5 6 7 8 9 10 11 12 13  def add_row(root: TreeNode, val: int, depth:int) -\u003e TreeNode: if depth == 1: return TreeNode(val, left=root) level = [root] while level and depth \u003e 2: level = [kid for node in level for kid in (node.left, node.right) if kid] depth -= 1 for node in level: node.left = TreeNode(val, left=node.left) node.right = TreeNode(val, right=node.right) return root   Integer to Roman  Given an integer [1, 3999], convert it to a roman numeral.\n 1 2 3 4 5 6  def to_roman(num: int) -\u003e str: thousands = ('', 'M', 'MM', 'MMM') hundreds = ('', 'C', 'CC', 'CCC', 'CD', 'D', 'DC', 'DCC', 'DCCC', 'CM') tens = ('', 'X', 'XX', 'XXX', 'XL', 'L', 'LX', 'LXX', 'LXXX', 'XC') ones = ('', 'I', 'II', 'III', 'IV', 'V', 'VI', 'VII', 'VIII', 'IX') return thousands[num//1000] + hundreds[num//100%10] + tens[num//10%10] + ones[num%10]   Coin Change  Given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.\n  Return the fewest number of coins that you need to make up that amount. If that amount of money cannot by make up by any combination of the coins, return -1.\n  You may assume that you have an infinite number of each kind of coin.\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  def coin_change(coins: List[int], amount: int) -\u003e int: dp = [1] + [0] * amount for i in range(1, amount + 1): dp[i] = min((1+dp[i-c] for c in coins if i \u003e= c and dp[i-c]), default=0) return dp[-1]-1 def coin_change_bfs(coins: List[int], amount: int) -\u003e int: if amount == 0: return 0 queue, seen = deque([(0, 0)]), {0} while queue: value, piece = queue.popleft() for c in coins: temp = value + c if temp == amount: return piece + 1 if temp \u003c amount and temp not in seen: seen.add(temp) queue.append((temp, piece+1)) return -1   Check If a String Contains All Binary Codes of Size K  Given a binary string s and an integer k.\n  Return true if every binary code of length k is a substring of s. Otherwise, return false.\n 1 2 3 4 5  def has_all_codes(s: str, k: int) -\u003e bool: return all(bin(i)[2:].zfill(k) in s for i in range(1 \u003c\u003c k)) def has_all_codes(s: str, k:int) -\u003e bool: return len({s[i-k:i] for i in range(k, len(s)+1)}) == 1 \u003c\u003c k   Binary Trees With Factors  Given an array of unique integers, arr, where each integer arr[i] is strictly greater than 1.\n  We make a binary tree using these integers, and each number may be used for any number of times. Each non-leaf node’s value should be equal to the product of the values of its children.\n  Return the number of binary trees we can make. The answer may be too large so return the answer modulo 10**9+7.\n 1 2 3 4 5 6 7 8 9 10 11  def num_factored_binary_trees(arr: List[int]) -\u003e int: MOD = 10**9 + 7 arr.sort() d = {} for x in arr: d[x] = 1 for y in d: if x % y == 0: d[x] += d[y] * d.get(x // y, 0) d[x] %= MOD return sum(dp.values()) % MOD   Swapping Nodes in a Linked List  Given the head of a linked list, and an integer k.\n  Return the head of the linked list after swapping the values of the k-th node from the beginning the k-th node from the end (the list is 1-indexed).\n  Constraints: 1 \u003c= k \u003c= n (the number of nodes)\n 1 2 3 4 5 6 7 8 9 10 11  def swap_nodes(head: ListNode, k: int) -\u003e ListNode: start = end = cur = head while cur: k -= 1 if k \u003e 0: start = start.next elif k \u003c 0: end = end.next cur = cur.next start.val, end.val = end.val, start.val return head   ","description":"","tags":null,"title":"2021 March Week 2","uri":"/algorithms/challege/2021-march-week-2/"},{"categories":["Algorithms"],"content":"Distribute Candies  Alice has n candies, where the ith candy is of type candyType[i]. Alice notices that she started to gain weight, so she visited a doctor.\n  The doctor advised Alice to only eat n/2 of the candies she has (n is always even). Alice likes her candies very much, and she wants to eat the maximum number of different types of candies while still following the doctor’s advice.\n  Given the integer array candyType of length n, return the maximum number of different types of candies she can eat if she only eats n/2 of them.\n 1 2  def distribute_candies(candyType: List[int]) -\u003e int: return min(len(candyType)//2, len(set(candyType)))   Set Mismatch  You have a set of integers s, which originally contains all the numbers from 1 to n. Unfortunately, due to some error, one of the numbers in s got duplicated to another number in the set, which results in repetition of one number and loss of another number.\n  You are given an integer array nums representing the data status of this set after the error.\n  Find the number that occurs twice and the number that is missing and return them in the form of an array.\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  def find_error_nums(nums: List[int]) -\u003e List[int]: dup = missing = 0 for x in nums: i = abs(x) - 1 if nums[i] \u003c 0: dup = i + 1 else: nums[i] *= -1 for i, x in enumerate(nums): if x \u003e 0: missing = i + 1 return [dup, missing] def find_error_nums_set(nums: List[int]) -\u003e List[int]: return [sum(nums) - sum(set(nums)), (len(nums)+1)*len(nums)//2 - sum(set(nums))] def find_error_nums_math(nums: List[int]) -\u003e List[int]: # m - t = d, s = m2 - t2 = (m-t)(m+t) = d(m+t) # m = (s/d + d)/2, t = (s/d - d)/2 d = s = 0 for i, x in enumerate(nums): d += i + 1 - x s += (i + 1)**2 - x**2 return [(s//d-d)//2, (s//d+d)//2]   Missing Number  Given an array nums containing n distinct numbers in the range [0, n], return the only number in the range that is missing from the array\n 1 2 3 4 5 6 7 8 9 10 11  def missing_number(nums: List[int]) -\u003e int: return reduce(operator.xor, chain(nums, range(len(nums)+1))) def missing_number_xor(nums: List[int]) -\u003e int: missing = len(nums) for i, x in enumerate(nums): missing ^= i ^ x return missing def missing_number_sum(nums: List[int]) -\u003e int: return (len(nums)+1)*len(nums)//2 - sum(nums)   Intersection of Two Linked Lists  Given the heads of two singly linked-lists headA and headB, return the node at which the two lists intersect. If the two linked lists have no intersection at all, return null.\n  It is guaranteed that there are no cycles anywhere in the entire linked structures.\n 1 2 3 4 5 6  def intersection_node(headA: ListNode, headB: ListNode) -\u003e ListNode: a, b = headA, headB while a != b: a = a.next if a else headB b = b.next if b else headA return a   Average of Levels in Binary Tree  Given the root of a binary tree, return the average value of the nodes on each level in the form of an array. answers with 1e-5 of the actual answer will be accepted.\n 1 2 3 4 5 6 7 8 9 10  def average_of_level(root: TreeNode) -\u003e List[float]: if not root: return [] result = [] level = [root] while level: result.append(sum(n.val for n in level)/len(level)) level = [kid for n in level for kid in (n.left, n.right) if kid] return result   Short Encoding of Words  A valid encoding of an array of words is any reference string s and array of indices indices such that:\n words.length == indices.length The reference string s ends with the # character. for each index indices[i], the substring of s starting from indices[i] and up to (but not including) the next # character is equal to words[i].    Given an array of words, return the length of the shortest reference string s possible of any valid encoding of words.\n 1 2 3 4 5 6 7  def shortest_encoding(words: List[str]) -\u003e int: s = set(words) for word in sorted(words, key=len): if word in s: for i in range(len(word)): s.discard(word[i:]) return sum(len(x)+1 for x in s)   Design HashMap ","description":"","tags":null,"title":"2021 March Week 1","uri":"/algorithms/challege/2021-march-week-1/"},{"categories":["Algorithms"],"content":"Longest Word in Dictionary through Deleting  Given a string s and a string array dict, return the longest string in the dictionary that can be formed by deleting some of the given string characters. If there is more than one possible result, return the longest word with the smallest lexicographical order. If there is no possible result, return the empty string.\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  def longest_word(s: str, d: List[str]) -\u003e str: def contains(s, word): m, n = len(s), len(word) if m \u003c n: return False i = j = 0 while i \u003c m and j \u003c n: if word[j] == s[i]: j += 1 i += 1 return j \u003e= n d.sort(key=lambda x: (-len(x), x)) for word in d: if contains(s, word): return word return ''   Search a 2D Matrix II  Write an efficient algorithm that searches for a target value in an m x n integer matrix. The matrix has the following properties:\n Integers in each row are sorted in ascending from left to right. Integers in each column are sorted in ascending from top to bottom   1 2 3 4 5 6 7 8 9 10 11 12  def search_matrix(matrix: List[List[int]], target: int) -\u003e bool: m, n = len(matrix), len(matrix[0]) i, j = 0, n-1 while i \u003c m and j \u003e= 0: if matrix[i][j] == target: return True if matrix[i][j] \u003e target: j -= 1 else: i += 1 return False   Score of Parentheses  Given a balanced parentheses string s, compute the score of the string based on the following rule:\n () has score 1. AB has score A + B, where A and B are balanced parentheses strings. (A) has score A * 2, where A is a balanced parentheses string.   1 2 3 4 5 6 7 8 9 10 11  def score_of_parentheses(s: str) -\u003e int: stack = [] for c in s: if c == ')': value = 0 while stack[-1] != '(': value += stack.pop() stack[-1] = value * 2 if value else 1 else: stack.append(c) return sum(stack)   Shortest Unsorted Continuous Subarray  Given an integer array nums, you need to find one continuous subarray that if you only sort this subarray in ascending order, then the whole array will be sorted in ascending order.\n  Return the shortest such subarray and output its length\n 1 2 3  def find_unsorted_subarray(nums: List[int]) -\u003e int: t = [i for i, (x, y) in enumerate(zip(nums, sorted(nums))) if x != y] return t[-1] - t[0] + 1 if t else 0   Validate Stack Sequences  Given two sequences pushed and popped with distinct values, return true if and only if this could have been the result of a sequence of push and pop operations on an initially empty stack.\n 1 2 3 4 5 6 7 8 9  def validate_stack(pushed: List[int], popped: List[int]) -\u003e bool: stack = [] i = 0 for x in pushed: stack.append(x) while stack and stack[-1] == popped[i]: stack.pop() i += 1 return len(popped) == i   Divide Two Integers  Given two integers dividend and divisor, divide two integers without using multiplication, division, and mod operator.\n  Return the quotient after dividing dividend by divisor.\n 1 2 3 4 5 6 7 8 9  def divide(dividend: int, divisor: int) -\u003e int: negative = (dividend \u003c 0) != (divisor \u003c 0) x, y = abs(dividend), abs(divisor) result = 0 for i in range(31, -1, -1): if x \u003e\u003e i \u003e= y: result += 1 \u003c\u003c i x -= y \u003c\u003c i return -result if negative else result   Maximum Frequency Stack  Design a stack-like data structure to push elements to the stack and pop the most frequent element from the stack.\n  Implement the FreqStack class:\n FreqStack() constructs an empty frequency stack. void push(int val) pushes an integer val onto the top of the stack int pop() removes and returns the most frequent element in the stack.  If there is a tie for the most frequent element, the element closet to the stack’s top is removed and returned.     1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  class FreqStack: def __init__(self): self._counter = Counter() self._group = defaultdict(list) self._height = 0 def push(self, x: int) -\u003e None: h = self._counter[x] + 1 self._counter[x] = h self._group[h].append(x) self._height = max(self._height, h) def pop(self) -\u003e int: x = self._group[self._height].pop() self._counter[x] -= 1 if not self.group[self._height]: self._height -= 1 return x   ","description":"","tags":null,"title":"2021 February Week 4","uri":"/algorithms/challege/2021-february-week-4/"},{"categories":["Algorithms"],"content":"1876. Substrings of Size Three with Distinct Characters  A string is good if there are no repeated characters.\n  Given a string s, return the number of good substrings of length three in s.\n 1 2  def count_good_substrings(s: str) -\u003e int: return sum(1 for i in range(len(s) - 2) if len(set(list(i:i+3))) == 3)   1877. Minimize Maximum Pair Sum in Array  The pair sum of a pair (a, b) is equal to a+b. The maximum pair sum is the largest pair sum in a list of pairs.\n  Given an array nums of even length n, pair up the elements of nums into n/2 pairs such that:\n Each element of nums is in exactly one pair, and The maximum pair sum is minimized. Return the minimized maximum pair sum after optimally pairing up the elements.   1 2 3  def min_max_pair_sum(nums: List[int]) -\u003e int: nums.sort() return max(nums[i] + nums[-1-i] for i in range(len(nums) // 2))   1878. Get Biggest Three Rhombus Sums in a Grid  Given an m x n integer matrix grid.\n  A rhombus sum is the sum of the elements that form the border of a regular rhombus shape in grid. The rhombus must have the shape of a square rotated 45 degrees with each of the corners centered in a grid cell.\n  Return the biggest three distinct rhombus sums in the grid in descending order. If there are less than three distinct values, return all of them.\n 1 2 3 4 5 6  def biggest_three_rhombus_sum(grid: List[List[int]]) -\u003e List[int]: m, n = len(grid), len(grid[0]) prefix = [[0] *(n+2) for _ in range(m+1)] for i in range(m): for j in range(n): prefix[i+1][j+1] = (prefix[i][j] + grid[i][j], prefix[i+2][j] + grid[i][j])   1879. Minimum XOR Sum of Two Arrays  Given two integer arrays nums1 and nums2 of length n.\n  The XOR sum of the two integer arrays is nums1[i] XOR nums2[i] for i -\u003e 0 until n.\n  Rearrange the elements of nums2 such that the resulting XOR sum is minimized.\n  Return the XOR sum after the rearrangement.\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  def min_xor_sum(nums1: List[int], nums2: List[int]) -\u003e int: n = len(nums2) @lru_cache(None) def dfs(i, seen): if i \u003e= n: return 0 result = float('inf') for j in range(n): if (seen \u0026 (1 \u003c\u003c j)) == 0: result = min(result, (nums1[i] ^ nums2[j]) + dfs(i+1, seen | (1 \u003c\u003c j))) return result return dfs(0, 0)   ","description":"","tags":null,"title":"Biweekly Contest 53","uri":"/algorithms/contest/biweekly-contest-53/"},{"categories":["Algorithms"],"content":"The K Weakest Rows in a Matrix  Given an m x n binary matrix mat of 1’s (representing soldiers) and 0’s (representing civilians). The soldiers are positioned in front of the civilians. That is, all the 1’s will appear to the left of all the 0’s in each row. A row i is weaker than a row j if one of the following is true:\n The number of soldiers in row i is less than the number of soldiers in row j. Both rows have the same number of soldiers and i \u003c j. Return the indices of the k weakest rows in the matrix ordered from weakest to strongest.   Solution 1 2  def k_weakest_rows(matrix: List[List[int]], k: int) -\u003e List[int]: return nsmallest(k, range(len(matrix)), key=lambda i: sum(matrix[i]))   Letter Case Permutation  Given a string S, we can transform every letter individually to be lowercase or uppercase to create another string. Return a list of all possible strings we could we could create. You can return the output in any order.\n Solution 1 2 3 4 5 6 7 8  def letter_case_permutation(s: str) -\u003e List[str]: result = [''] for c in S: if c.isdigit(): result = [item + c for item in result] else: result = [item + t for item in result for t in (c.lower(), c.upper())] return result   Container With Most Water  Given n non-negative integers $a_1, a_2, …, a_n$, where each represents a point at coordinate $(i, a_i)$. n vertical lines are drawn such that the two endpoint of the line i is at $(i, a_i)$ and $(i, 0)$. Find two lines, which, together with the x-axis forms a container, such that the container the most water.\n Solution 1 2 3 4 5 6 7 8 9 10  def most_water(heights: List[int]) -\u003e int: start, end = 0, len(heights)-1 result = 0 while start \u003c end: result = max(result, min(heights[start], heights[end]) * (end - start)) if heights[start] \u003e heights[end]: end -= 1 else: start += 1 return result   Arithmetic Slices  An integer array is called arithmetic if it consist of at least three elements and if the difference between any two consecutive elements is the same.\n For example, [1,3,5,7,9], [7,7,7,7] and [3,-1,-5,-9] are arithmetic sequences. Given an integer array nums, return the number of arithmetic subarray of nums.   Solution 1 2 3 4 5 6 7 8 9 10 11  def arithmetic_slices(nums: List[int]) -\u003e int: result = 0 delta = [nums[i+1] - nums[i] for i in range(len(nums) - 1)] for _, part in groupby(delta): n = len(part) if n \u003e 1: result += n * (n-1) // 2 return result def arithmetic_slices(nums: List[int]) -\u003e int:   Minimum Remove to Make Valid Parentheses  Given a string of (,) and lowercase English characters. You task is to remove the minimum number of parentheses ('(', ')', in any positions) so that the result parentheses string is valid amd return any valid string.\n Solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  def minimum_remove_to_make_valid(s: str) -\u003e str: result = list(s) left = [] for i, c in enumerate(result): if c == '(': left.append(i) elif c == ')': if left: left.pop() else: result[i] = '' while left: result[left.pop()] = '' return ''.join(result)   Roman to Integer  Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M. Given a roman numeral [1, 3999], convert it to an integer.\n Solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  def roman_to_int(r: str) -\u003e int: R = { \"I\": 1, \"V\": 5, \"X\": 10, \"L\": 50, \"C\": 100, \"D\": 500, \"M\": 1000 } result = 0 prev = 1000 for c in r: result += d[c] if prev \u003c d[c]: result -= prev * 2 prev = d[c] return result   Broken Calculator  On a broken calculator that has a number showing on its display, we can perform two operations:\n Double: Multiply the number on the display by 2, or; Decrement: Subtract 1 from the number on the display. Return the minimum number of operation of operations needed to display the number Y from the initial value X.   Solution 1 2 3 4 5 6 7 8 9 10  def broken_calculator(x: int, y: int) -\u003e int: result = 0 while x \u003c y: result += 1 if y % 2: y += 1 # decrement else: y //= 2 return result + x - y   ","description":"","tags":null,"title":"2021 February Week 3","uri":"/algorithms/challege/2021-february-week-3/"},{"categories":["Algorithms"],"content":"Peeking Iterator  Design an iterator that supports the peek operation on a list in addition to the hasNext and the next operations. Implement the PeekingIterator class:\n PeekingIterator(int[] nums) Initializes the object with the given integer array nums`. int next() Returns the next elements in the array and moves the pointer to the next element. bool hasNext() Returns true if there are still elements in the array. int peek() Returns the next element in the array without moving the pointer.   Solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  # class Iterator: # def __init__(self, nums): # pass #  # def hashNext(self): # pass #  # def next(self): # pass class PeekingIterator: def __init__(self, iterator): self.__it = iterator self.__value = self.__it.next() if self.__it.hasNext() else None def peek(self): return self.__value def next(self): result = self.__value self.__value = self.__it.next() if self.__it.hashNext() else None def hasNext(self): return self.__value is not None   Convert BST to Greater Tree  Given the root of a Binary Search Tree (BST), convert it to a Greater Tree such that every key of the original BST is changed to the original key plus sum of all keys greater than the original key in BST.\n  As a reminder, a binary search tree is a tree that satisfies these constraints:\n The left subtree of a node contains only nodes with keys less than the node’s key. The right subtree of a node contains only nodes with keys greater than the node’s key. Both the left and right subtrees must also be binary search trees.   Solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  def solve(root: TreeNode) -\u003e TreeNode: value = 0 node = root stack = [] while stack or node: if node: stack.append(node) node = node.right else: node = stack.pop() value += node.val node.val = value node = node.left return root def solve(root: TreeNode) -\u003e TreeNode: def dfs(node, value): if not node: return value value = dfs(node.right, value) node.val += value return dfs(node.left, node.val) dfs(root, 0) return root   Copy List with Random Pointer Solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  # class Node: # def __init__(self, x: int, next: Node=None, random: Node=None): # self.x = x # self.next = next # self.random = random def solve(head: Node) -\u003e Node: if not head: return None cur = head while cur: cur.next = Node(cur.x, cur.next, cur.random) cur = cur.next.next cur = head while cur: cur.next.random = cur.random.next if cur.random else None cur = cur.next.next cur = head.next while cur: cur.next = cur.next.next if cur.next else None cur = cur.next return head.next   Valid Anagram  Given two strings s and t, return true if t is an anagram of s, and false otherwise.\n 1 2 3  def solve(s: str, t: str) -\u003e bool: return sorted(s) == sorted(t) # return Counter(s) == Counter(t)   Number of Steps to Reduce a Number to Zero  Given a non-negative integer num, return the number of steps to reduce it to zero. If the current number is even, you have to divide it by 2, otherwise, you have to subtract 1 from it.\n Solution 1 2 3 4 5 6  def solve(num: int) -\u003e int: result = 0 while num: num = num - 1 if num % 2 else num // 2 result += 1 return result   Shortest Path in Binary Matrix  Given an n x n binary matrix grid, return the length of the shortest clear path in the matrix. If there is no clear path, return -1. A clear path in a binary matrix is a path from the top-left cell (i.e., (0, 0)) to the bottom-right cell (i.e., (n-1, n-1)) such that:\n All the visited cells of the path are 0. All the adjacent cells of the path are 8-directionally connected (i.e., they are different and they share an edge or a corner). The length of a clear path is the number of visited cells of this path.   Solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  def solve(grid: List[List[int]]) -\u003e int: if grid[0][0] == 1 or grid[-1][-1] == 1: return -1 DIR = ((1,0),(1,1),(1,-1),(0,1),(0,-1),(-1,1),(-1,0),(-1,-1)) n = len(grid) queue = deque([(0, 0, 1)]) while queue: x, y, d = queue.popleft() if x == y == n-1: return d for dx, dy in DIR: i, j = x+dx, y+dy if 0 \u003c= i \u003c n and 0 \u003c= j \u003c n and grid[i][j] == 0: grid[i][j] = 1 queue.append((i, j, d+1)) return -1   Is Graph Bipartite?  There is an undirected graph with n nodes, where each node is numbered between 0 and n-1. You are given a 2D array graph, where graph[u] is an array of nodes that node u is adjacent to. More formally, for each v in graph[u], there is an undirected edge between node u and node v. The graph has the following properties:\n There are no self-edges (graph[u] does not contain u). There are no parallel edges (graph[u] does not contain duplicate values). If v is in graph[u], then u is in graph[v] (the graph is undirected). The graph may not be connected, meaning there may be two nodes u and v such that there is no path between them.    A graph is bipartite if the nodes can be partitioned into two independent sets A and B such that every edge in the graph connects a node in set A and a node in set B.\n  Return true if and only if it is bipartite.\n Solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  def is_bipartite(graph: List[List[int]]) -\u003e bool: n = len(graph) color = [0] * n for i in range(n): if color[i]: continue queue = deque([i]) color[i] = 1 while queue: v = queue.popleft() for u in graph[v]: if color[u] == color[v]: return False if color[u] == 0: color[u] = -color[v] queue.append(u) return True   ","description":"","tags":null,"title":"2021 February Week 2","uri":"/algorithms/challege/2021-february-week-2/"},{"categories":["Algorithms"],"content":"Number of 1 bits  Write a function that takes an unsigned integer and returns the number of 1 bits it has (also know as the Hamming weight).\n Intuition Use x \u0026 (x-1) remove the rightmost 1 bit.\nSolution 1 2 3 4 5 6  def count_1s(n: int) -\u003e int: result = 0 while n: result += 1 n \u0026= n-1 return result   Trim a Binary Search Tree  Given the root of a binary search tree and the lowest and highest boundaries as low and high, trim the tree so that all its elements lies in [low, high]. Trimming the tree should not change the relative structure of the elements that will remain in the tree (i.e., any node’s descendant should remain a descendant). It can be proven that there is a unique answer.\nReturn the root of the trimmed binary search tree. Note that the root may change depending on eht given bounds.\n Intuition if the value of a node is less than low, use the right kid instead of the left. if the value of a node is greater than high, use the left kid instead of the right.\nSolution 1 2 3 4 5 6 7 8 9 10  def solve(root: TreeNode, low: int, high: int) -\u003e TreeNode: if not root: return None if root.val \u003c low: return solve(root.right, low, high) if root.val \u003e high: return solve(root.left, low, high) root.left = solve(root.left, low, high) root.right = solve(root.right, low, high) return root   Linked List Cycle  Given head, the head of a linked list, determine if the linked list has a cycle in it.\nReturn true if there is a cycle in the linked list. Otherwise, return false.\n Intuition If there is a cycle in the linked list cycle, the fast pointer will meet the slow pointer. Otherwise, the fast will hit the end None.\nSolution 1 2 3 4 5 6 7 8  def solve(head: ListNode) -\u003e bool: fast = slow = head while fast and fast.next: fast = fast.next.next slow = slow.next if fast == slow: return True return False   Longest Harmonious Subsequence  Defined a harmonious array as an array where the difference between its maximum value and its minimum value is exactly 1.\nGiven an integer array nums, return the length of its longest harmonious subsequence among all its possible subsequences.\n Intuition Solution 1 2 3  def solve(nums: List[int]) -\u003e int: counter = Counter(nums) return max(counter[k] + counter[k-1] for k in counter if k-1 in counter, default = 0)   Simplify Path  Given a string path, which is an absolute path (starting with a slash '/') to a file or directory in a Unix-style file system, convert it to the simplified canonical path.\n Solution 1 2 3 4 5 6 7 8 9 10  def solve(path: str) -\u003e str: items = path.split('/') result = [] for item in items: if item == '..': if result: result.pop() elif item != '.' and item != '': result.append(item) return '/' + '/'.join(result)   Binary Tree Right Side View  Given the root of a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.\n Solution 1 2 3 4 5 6 7 8 9 10  def solve(root: TreeNode) -\u003e List[int]: if not root: return [] result = [] level = [root] while level: result.append(level[-1].val) level = [kid for node in level for kid in (node.left, node.right) if kid] return result   Shortest Distance to a Character  Given a string s and a character c that occurs in s, return an array of integers answer where answer.length == s.length and answer[i] is the distance from index i to the closest occurrence of character c in s.\n Intuition Solution 1 2 3 4 5 6 7 8 9 10 11 12 13  def solve(s: str, c: str) -\u003e List[int]: prev = float('-inf') n = len(s) result = [n] * n for i in range(n): if s[i] == c: prev = i result[i] = min(result[i], i - prev) for i in range(n-1, -1, -1): if s[i] == c: prev = i result[i] = min(result[i], prev - i) return result   ","description":"","tags":null,"title":"2021 February Week 1","uri":"/algorithms/challege/2021-february-week-1/"},{"categories":["Algorithms"],"content":"Vertical Order Traversal of a Binary Tree  Given the root of a binary tree, calculate the vertical order traversal of the binary tree.\nNote: There may be multiple nodes in the same row and same column. In such a case, sort these nodes by their values.\n Solution 1 2 3 4 5 6 7 8 9 10 11 12 13  def solve(root: ListNode) -\u003e List[List[int]]: level = [(root, 0)] columns = defaultdict(list) while level: for c, val in sorted([(c, node.val) for node, c in level]): columns[c].append(val) level = [ (kid, t) for node, c in level for kid, t in ((node.left, c-1), (node.right, c+1)) if kid ] return [columns[c] for c in sorted(columns.keys())]   Minimize Deviation in Array  Given an array nums of n positive integers. You can perform two types of operations on any element of the array any number of times:\n If the element is even, divide it by 2. If the element is odd, multiply it by 2.  The deviation of the array is the maximum difference between any two elements in the array.\nReturn the minimum deviation the array can have after performing some number of operations.\n Solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  def solve(nums: List[int]) -\u003e int: heap = [] for x in nums: temp = x while temp % 2 == 0: temp //= 2 heappush(heap, (temp, max(x, temp*2))) lower = max(i for i, _ in heap) result = float('inf') while len(heap) == len(nums): x, upper = heappop(heap) result = min(result, lower - x) if x \u003c upper: heappush(heap, (x*2, upper)) lower = max(lower, x*2) return result   Next Permutation  Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.\nIf such an arrangement is not possible, it must rearrange it as the lowest possible order (i.e., sorted in ascending order).\nThe replacement must be in place and use only constant extra memory.\n Solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  def solve(nums: List[int]) -\u003e None: i = len(nums)-2 while i \u003e -1 and nums[i] \u003e= nums[i+1]: i -= 1 if i == -1: nums.reverse() return j = len(nums) -1 while nums[j] \u003c= nums[i]: j -= 1 nums[i], nums[j] = nums[j], nums[i] start, end = i+1, len(nums)-1 while start \u003c end: nums[start], nums[end] = nums[end], nums[start] start, end = start+1, end-1   ","description":"","tags":null,"title":"2021 January Week 5","uri":"/algorithms/challege/2021-january-week-5/"},{"categories":["Algorithms"],"content":"Determine if Two Strings Are Close  Two strings are considered close if you can attain one from the other using the following operations:\n Operation 1: Swap any two existing characters. eg. abcde -\u003e aecdb, (b \u003c-\u003e e) Operation 2: Transform every occurrence of one existing character into another existing character, and do the same with the other character. eg. aacabb -\u003e bbcbaa (a \u003c-\u003e b).  You can use the operations on either string as many times as necessary.\nGiven two strings, word1 and word2, return true if word1 and word2 are close, and false otherwise.\n Solution 1 2 3 4 5 6 7  def solve(s: str, t: str) -\u003e bool: cs = Counter(s) ct = Counter(t) return ( sorted(cs.keys()) == sorted(ct.keys()) and sorted(cs.values()) == sorted(ct.values()) )   Sort the Matrix Diagonally  A matrix diagonal is a diagonal line of cells starting from some cell in either the topmost row or leftmost column and going in the bottom-right direction until reaching the matrix’s end. For example, the matrix diagonal starting from mat[2][0], when mat is a 6x3 matrix, includes cells mat[2][0], mat[3][1] and mat[4][2].\nGiven an m x n matrix mat of integers, sort each matrix diaginal in ascending order and return the resulting matrix.\n Solution 1 2 3 4 5 6 7 8 9 10 11  def solve(mat: List[List[int]]) -\u003e List[List[int]]: m, n = len(mat), len(mat[0]) diagonal = defaultdict(list) for i in range(m): for j in range(n): insort(diagonal[i-j], mat[i][j]) for i in range(m): for j in range(n): mat[i][j] = diagonal[i-j].pop(0) return mat   Merge k Sorted Lists  Given an array of k linked-lists lists, each linked-list is sorted in ascending order.\nMerge all the linked-lists into one sorted linked-list and return it.\n Solution 1 2 3 4 5 6 7 8 9 10 11 12  def solve(lists: List[ListNode]) -\u003e ListNode: heap = [] for head in lists: heappush(heap, (head.val, i, head)) c = dummy = ListNode() while heap: _, i, c.next = heappop(heap) c = c.next if c and c.next: heappush(heap, (c.next.val , i, c.next)) return dummy.next   Check if All 1’s Are at Least Length K Places Away  Given an array nums of 0s and 1s and an integer k, return True if all 1s are a least k places away from each other, otherwise return False.\n Solution 1 2 3 4 5 6 7 8  def solve(nums: List[int], k: int) -\u003e bool: prev = float('-inf') for i, x in enumerate(nums): if x: if i - prev \u003c= k: return False prev = i return True   Path with Minimum Effort  You are a hiker preparing for an upcoming hike. You are given heights, a 2D array of size rows x columns, where heights[row][col] represents the height of cell (row, col). You are situated in the top-left cell, (0, 0), and you hope to trvel to the bottom-right cell, (rows-1, columns-1). You can move up, down, left, or right, and you wish to find a route that requires the minimum effort.\nA route’s effort is the maximum absolute difference in heights between two consecutive cells of the route.\nReturn the minimum effort required to travel from the top-left cell to the bottom-right cell.\n Solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42  def solve(heights: List[List[int]]) -\u003e int: DIR = ((1, 0), (-1, 0), (0, 1), (0, -1)) m, n = len(heights), len(heights[0]) distance = [[float('inf')] * n for _ in range(m)] heap = [(0, 0, 0)] # distance, i, j while heap: d, r, c = heappop(heap) if d \u003e distance[r][c]: continue if r == m-1 and c == n-1: return d for dr, dc in DIR: x, y = r+dr, c+dc if 0 \u003c= x \u003c m and 0 \u003c= y \u003c n: temp = max(d, abs(heights[x][y] - heights[r][c])) if distance[x][y] \u003e temp: distance[x][y] = temp heappush(heap, (distance[x][y], x, y)) def solve2(heights: List[List[int]]) -\u003e int: DIR = ((1, 0), (-1, 0), (0, 1), (0, -1)) m, n = len(heights), len(heights[0]) def dfs(limit, r, c): for dr, dc in DIR: x, y = r+dr, c+dc if 0 \u003c= x \u003c m and 0 \u003c= y \u003c n and (x, y) not in seen and abs(heights[x][y] - heights[r][c]) \u003c= limit: seen.add((x, y)) if x == m-1 and y == n-1: return dfs(limit, x, y) start, end = 0, max(max(heights, key=max)) while start \u003c end: mid = (start + end) // 2 seen = {(0, 0)} dfs(mid, 0, 0) if (m-1, n-1) in seen: end = mid else: start = mid + 1 return end   Concatenation of Consecutive Binary Numbers  Given an integer n, return the decimal value of the binary string formed by concatenating the binary representations of 1 to n in order, modulo 10**9+7.\n Solution 1 2 3 4 5 6 7 8 9 10 11  def solve(n: int) -\u003e int: return int(''.join(bin(i)[2:] for i in range(1, n+1)), 2) % (10**9 + 7) def solve2(n: int) -\u003e int: MOD = 10**9 + 7 result = shift = 0 for i in range(1, n+1): if i \u0026 (i-1) == 0: shift += 1 result = (result \u003c\u003c shift + i) % MOD return result   Smallest String with a Given Numeric Value  The numeric value of a lowercase character is defined as its position (1-indexed) in the alphabet, so the numeric value of a is 1, the numeric value of b is 2, the numeric value of c is 3, and so on.\nThe numeric value of a string consisting of lowercase characters is defined as the sum of its characters' numeric values. For example, the numeric value of the string \"abc\" is equal to 1+2+5=8.\nYou are given two integers n and k. Return the lexicographically smallest string with length equal to n and numeric value equal to `k.\nNote that a string x is lexicographically smaller than string y if x comes before y in dictionary order, that is, either x is prefix of y, or if i is the first position such that x[i] != y[i], then x[i] comes before y[i] in alphabetic order.\n Solution 1 2 3 4 5  def solve(n: int, k: int) -\u003e str: z, rem = divmod(k - n, 25) if rem: return 'a' * (n-z-1) + chr(97 + rem) + 'z' * z return 'a' * (n-z) + 'z' * z   ","description":"","tags":null,"title":"2021 January Week 4","uri":"/algorithms/challege/2021-january-week-4/"},{"categories":["Algorithms"],"content":"Get Maximum in Generated Array  Given an integer n. An Array nums of length n+1 is generated in the following way:\n nums[0] = 0 nums[1] = 1 nums[2i] = nums[i], when `2 \u003c= 2i \u003c= n nums[2i + 1] = nums[i] + nums[i+1], when `2 \u003c= 2i + 1 \u003c= n  Return the maximum integer in the array nums.\n Solution 1 2 3 4 5 6 7 8 9 10 11 12 13  def solve(n): if n \u003c 2: return n x = [0] * (n + 1) x[1] = 1 for i in range(2, n): j, odd = divmod(i, 2) if odd: x[i] = x[j] + x[j+1] else: x[i] = x[j] result = max(result, x[i]) return result   Kth Largest Element in an Array  Given an integer array nums and an integer k, return the kth largest element in the array.\n Solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  def solve(nums: List[int], k: int) -\u003e int: return nlargest(k, nums)[-1] def solve2(nums: List[int], k: int) -\u003e int: start, end = 0, len(nums) while start \u003c end: p = randint(start, end-1) nums[p], nums[end-1] = nums[end-1], nums[p] i = start for j in range(start, end-1): if nums[j] \u003e nums[i]: nums[i], nums[j] = nums[j], nums[i] i += 1 nums[i], nums[end-1] = nums[end-1], nums[i] if i == k - 1: return nums[i] elif i \u003e k - 1: end = i else: start = i + 1   Count Sorted Vowel Strings  Given an integer n, return the number of strings of length n that consist only of vowels (a, e, i, o, u) and are lexicographically sorted.\nA string s is lexicographically sorted if for all valid i, s[i] is the same as or comes before s[i+1] in the alphabet.\n Solution 1 2 3 4 5  def solve(n: int) -\u003e int: a = e = o = i = u = 1 for _ in range(n): a, e, i, o, u = a+e+i+o+u, e+i+o+u, i+o+u, o+u, u return a   Max Number of K-Sum Pairs  Given an integer array nums and an integer k.\nIn one operation, you can pick two numbers from the array whose sum equals k and remove them from array.\nReturn the maximum number of operations you can perform on the array.\n Solution 1 2 3 4 5 6 7 8 9 10  def solve(nums: List[int], k: int) -\u003e int: result = 0 d = defaultdict(int) for x in nums: if d[x] \u003e 0: result += 1 d[x] -= 1 else: d[k - x] += 1 return result   Longest Palindromic Substring  Given a string s, return the longest palindromic substring in s.\n 1 2 3 4 5 6 7 8 9 10  def solve(s: str) -\u003e str: def palindromic(i: int, j: int) -\u003e str: while 0 \u003c i and j \u003c len(s) and s[i] == s[j]: i, j = i-1, j+1 return s[i+1:j] result = '' for i in range(len(s)): result = max(result, palindromic(i, i), palindromic(i, i+1), key=len) return result   Valid Parentheses  Given a string s containing just the characters (, ), {, }, [ and ], determine if the input string is valid. An input string is valid if:\n Open brackets must be closed by the same type of brackets. Open brackets must be closed in the correct order.   1 2 3 4 5 6 7 8 9 10 11 12  def solve(s: str) -\u003e bool: brackets = {')': '(', ']': '[', '}': '{'} stack = [] for c in s: if c in brackets: if stack and stack[-1] == brackets[c]: stack.pop() else: return False else: stack.append(c) return not stack   Find the Most Competitive Subsequence  Given an integer array nums and a positive integer k, return the most competitive subsequence of nums of size k.\nAn array’s subsequence is a resulting sequence obtained by erasing some (possibly zero) elements from the array.\nWe define that a subsequence a is more competitive than a subsequence b (of the same length) if in the first position where a and b differ, subsequence a has a number less than the corresponding number in b. For example, [1,3,4] is more competitive than [1,3,5] because the first position they differ is at the final number and 4 is less than 5.\n Solution 1 2 3 4 5 6 7 8 9  def solve(nums: List[int], k: int) -\u003e List[int]: n = len(nums) stack = [] for i, x in enumerate(nums): while stack and stack[-1] \u003e x and len(stack) - 1 + n - i \u003e= k: stack.pop() if len(stack) \u003c k: stack.append(x) return stack   ","description":"","tags":null,"title":"2021 January Week 3","uri":"/algorithms/challege/2021-january-week-3/"},{"categories":["Algorithms"],"content":"","description":"","tags":null,"title":"Weekly Contest 223","uri":"/algorithms/contest/weekly-contest-223/"},{"categories":null,"content":"Check If Two String Arrays are Equivalent  Given two strings s and t, return true if the two arrays represent the same string, and false otherwise.\nA string is represented by an array if the array elements concatenated in order forms the string.\n Intuition Solution 1 2 3  def solve(s: List[str], t: List[str]) -\u003e bool: return all(i == j for i, j in zip_longest(chain(*s), chain(*t)) # return ''.join(s) == ''.join(t)   Word Ladder  A transformation sequence from word beginWord to word endWord using a dictionary wordList is a sequence of words beginWord -\u003e s1 -\u003e s2 -\u003e ... -\u003e sk, such that:\n Every adjacent pair of words differs by a single letter. Every si for 1 \u003c= i \u003c= k is in wordList. Note that beginWord does not need to be in wordList. sk == endWord  Given two words, beginWord and endWord, and a dictionary wordList, return the number of words in the shortest transformation sequence from beginWord to endWord, or 0 if no such sequence exists.\n Intuition Solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  def solve(words: List[str], begin: str, end: str) -\u003e int: if end not in words: return 0 aux = defaultdict(set) for w in words: for i in range(len(w)): key = w[0:i] + '?' + w[i+1:] aux[key].add(w) candidate = deque([(begin, 1)]) seen = {begin} while candidate: word, depth = candidate.popleft() for i in range(len(word)): key = word[0:i] + '?' + word[i+1:] for w in aux[key]: if w == end: return depth + 1 if w not in seen: seen.add(w) candidate.append((w, depth+1)) return 0   Create Sorted Array through Instructions  Given an integer array instructions, you are asked to create a sorted array from the elements in instructions. You start with an empty container nums. For each element from left to right in instructions, insert it into nums. The costof each insertion is the minimum of the following:\n The number of elements currently in nums that are strictly less than instructions[i]. The number of elements currently innums that are strictly greater than instructions[i].  For example, if inserting element 3 into nums = [1,2,3,5], the cost of insertion is min(2,1) (element1 1 and 2 are less than 3, element 5 is greater than 3) and nums will become [1,2,3,3,5]. Return the total cost to insert all elements from instructions into nums. Since tha answer may be large, return it modulo 10**9 + 7.\n Solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41  def solve(instructions: List[int]) -\u003e int: MOD = 10**9 + 7 result = 0 aux = [] for i, x in enumerate(instructions): left, right = bisect_left(aux, x), bisect_right(aux, x) result += min(left, i - right) aux[right:right] = [x] # aux.insert(right, x) # insort(aux, x) return result % MOD class Bit: def __init__(self, n): self.__n = n self.__bit = [0] * (n + 1) def query(self, x): result = 0 while x \u003e 0: result += self.__bit[x] x -= -x \u0026 x return result def update(self, x): while x \u003c= self.__n: self.__bit[x] += 1 x += -x \u0026 x def solve2(instructions: List[int]) -\u003e int: MOD = 10**9 + 7 n = max(instructions) bit = Bit(n) result = 0 for i, n in enumerate(instructions): result += min(bit.query(n-1), i - bit.query(n)) bit.update(n) return result % MOD   Merge Sorted Array  Given two sorted integer nums1 and nums2, merge nums2 into nums1 as one sorted array.\n Intuition Solution 1 2 3 4 5 6 7 8 9 10 11 12  def solve(nums1: List[int], m: int, nums2: List[int], n: int) -\u003e None: end = m + n while m and n: if nums1[m-1] \u003e nums1[n-1]: nums1[end-1] = nums1[m-1] end, m = end-1, m-1 else: nums1[end-1] = nums2[n-1] end, n = end-1, n-1 while n \u003e 0: nums1[end-1] = nums2[n-1] end, n = end-1, n-1   Add Two Numbers  Given two non-empty linked lists representing two non-negative integers. The digits are stored in reversed order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\n Intuition Solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14  def solve(s: ListNode, t: ListNode) -\u003e ListNode: c = dummy = ListNode() carry = 0 while s or t or carry: if s: carry += s.val s = s.next if t: carry += t.val t = t.next carry, digit = divmod(carry, 10) c.next = ListNode(val=digit) c = c.next return dummy.next   Boats to Save People  Given an array people where people[i] is the weight of the ith person, and an infinite number of boats where each boat can carry a maximum weigth of limit. Each boat carries at most two people at the same time, provided the sum of the weight of those people is at most limit. Return the minimum number of boats to carry every given person.\n Intuition Solution 1 2 3 4 5 6 7 8 9 10  def solve(people: List[int], limit: int) -\u003e int: people.sort() result = 0 start, end = 0, len(people) - 1 while start \u003c= end: if people[start] + people[end] \u003c= limit: start += 1 end -= 1 result += 1 return result   Minimum Operations to Reduce X to Zero  Given a positive integer array nums and an integer x. In one operation, you can either remove the leftmost or the rightmost element from the array nums and subtract its value from x. Note that this modifies the array fro future operations. Return the minimum number of operations to reduce x to exactly 0 if it’s possible, otherwise, return -1. Constraints\n  1 \u003c= nums.length \u003c= 10**5  Intuition First, solving this problem using DP, but then realized that the constraints are too large.\nThen, thinking in reverse, that, instead of finding the minimum prefix + suffix, find the maximum subarray.\nFinal, finding the maximum subarray is standard and can be done greedily.\nSolution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  def solve(nums: List[int], x: int) -\u003e int: target = sum(nums) - x if target \u003c 0: return -1 n = len(nums) if target == 0: return n result = total = j = 0 for i in range(len(nums)): total += nums[i] while total \u003e target: total -= nums[j] j += 1 if total == target: result = max(result, i - j + 1) return n - result if result else -1   ","description":"","tags":null,"title":"2021 January Week 2","uri":"/algorithms/challege/2021-january-week-2/"},{"categories":["Algorithms"],"content":"Remove Duplates from Sorted Array  Given a sorted array nums, remove the duplicates in-place such that each element appears only once and returns the new length.\nDo not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.\n 1 2 3 4 5 6 7 8  def solve(nums): offset = 0 for x in nums: if x != nums[offset]: offset += 1 nums[offset] = x return offset + 1 if nums else 0   Best Time to Buy and Sell Stock II  You are given an array prices where prices[i] is the price of a given stock on the ith day.\nFind the maximum profit you can achieve. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times).\nNote: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).\n 1 2 3 4 5 6 7  def slove(prices): profit, n = 0, len(prices) for i in range(1, n): delta = prices[i] - prices[i-1] if delta \u003e 0: profit += delta return profit   ","description":"","tags":null,"title":"Top Easy","uri":"/algorithms/array/top-easy/"},{"categories":["Algorithms"],"content":"Maximum (Minimum) Path to Reach a Target Statement:\n Given a target find maximum (minimum) cost/path/sum to reach a target. Approach: Choose minimum (maximum) path among all possible paths before the current state, then add the current value. routes[i] = max(routes[j] for j in range(k, i-1)) + values[i]\n Min Cost Climbing Stairs LC746  Given a staircase, the i-th step has some non-negative cost cost[i]. You can either climb one or two steps, find minimum cost to reach the top of the staircase.\n 1 2 3 4 5  def solve(cost): s = t = 0 for x in cost: s, t = x + min(s, t), s retur min(s, t)   Minimum Path Sum LC64  Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path. You can only move either down or right at any point in time.\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14  def solve(grid): \"\"\" dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + cost \"\"\" m, n = len(grid), len(grid[0]) for i in range(m): grid[i][0] += grid[i-1][0] for j in range(n): grid[0][j] += grid[0][j-1] for i in range(1, m): for j in range(1, n): grid[i][j] += min(grid[i][j-1], grid[i-1][j]) return grid[-1][-1]   Coin Change LC322  Given coins of different denominations and a total amount of money amount. Return the fewest number of coins that you need to make up that amount. If that amount of money cannot made up, return -1. You may assume that you have an infinite number of each kind of coin.\n 1 2 3 4 5 6 7  def solve(coins, amount): dp = [0] + [-1] * amount for i in range(1, amount + 1): options = [dp[i-c] + 1 for c in coins if i \u003e= c and dp[i-c] \u003e -1] if options: dp[i] = min(options) return dp[-1]   1 2 3 4 5 6 7 8 9 10 11 12 13  def solve(coins, amount): dp = [0] + [-1] * amount queue = deque([0]) while queue: v = queue.popleft() for c in coins: j = c + v if j \u003c= amount and dp[j] == -1: dp[j] = 1 + dp[v] if j == amount: return dp[-1] queue.append(c + v) return dp[-1]   Minimum Falling Path Sum  Given a square array of integers grid, we want the minimum sum of a falling path through grid. A falling path starts at any element in the first row, and choose one element from each row. The next row’s choice must be in a column that is different from the previous row’s column by at most one.\n 1 2 3 4 5 6  def solve(grid): m, n = len(grid), len(grid[0]) for i in range(1, m): for j in range(n): grid[i][j] += min(grid[i-1][k] for k in range(j-1, j, j+1) if 0 \u003c= k \u003c n) return min(grid[-1])   ","description":"","tags":null,"title":"Reach Target","uri":"/algorithms/dynamic-programming/reach-target/"},{"categories":null,"content":"Number of Islands  Given an m x n 2d grid map of '1's (land) and '0's (water), return the number of islands. Assume all four edges of the grid are surrounded by water.\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  def solve(grid): result = 0 m, n = len(grid), len(grid[0]) for i in range(m): for j in range(n): if grid[i][j] == '1': result += 1 queue = deque([(i, j)]) grid[i][j] = '' while queue: x, y = queue.popleft() for dx, dy in ((-1, 0), (1, 0), (0, -1), (0, 1)): if 0 \u003c= x+dx \u003c m and 0 \u003c= y+dy \u003c n and grid[x+dx][y+dy] == '1': queue.append((x+dx, y+dy)) grid[x+dx][y+dy] = '' return result   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  def solve(grid): def dfs(grid, i, j): if grid[i][j] == '0': return grid[i][j] = '0' if i \u003e 0: dfs(grid, i-1, j) if j \u003e 0: dfs(grid, i, j-1) if i \u003c len(grid): dfs(grid, i+1, j) if i \u003c len(grid[0]): dfs(grid, i, j+1) result = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == '1': dfs(grid, i, j) result += 1 return result   Max Area of Island  Given a non-empty 2D array grid of 0’s and 1’s, and island is a group of 1’s (representing land) connected 4-directionary (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.\n  Find the maximum area of an island in the given 2D array. (if there is no island, the maximum area is 0)\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  def solve(grid): def dfs(grid, i, j): grid[i][j] = 0 result = 0 for di, dj in ((-1,0),(1,0),(0,1),(0,-1)): if 0 \u003c= i + di \u003c len(grid) and 0 \u003c= j + dj \u003c len(grid[0]) and grid[i+di][j+dj]: result += dfs(grid, i+di, j+dj) return result + 1 result = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j]: result = max(result, dfs(grid, i, j)) return result   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  def solve_bfs(grid): m, n = len(grid), len(grid[0]) result = 0 for i in range(m): for j in range(n): if grid[i][j]: count = 0 queue = deque([(i, j)]) grid[i][j] = 0 while queue: x, y = queue.popleft() count += 1 for dx, dy in ((-1,0), (1,0), (0,1), (0,-1)): if 0 \u003c= x + dx \u003c m and 0 \u003c= y + dy \u003c n and grid[x+dx][y+dy]: grid[x+dx][y+dy] = 0 queue.append((x+dx, y+dy)) result = max(result, count) return result   ","description":"","tags":null,"title":"Island","uri":"/algorithms/depth-first-search/island/"},{"categories":null,"content":"Remove Linked List Elements (LC203)  Remove all elements from a linked list of integers that have value val.\n 1 2 3 4 5 6 7 8 9  def solve(head, val): c = dummy = ListNode(next=head) while head: if head.val != val: c = head else: c.next = head.next head = head.next return dummy.next   Remove Duplicates from Sorted List (LC83)  Given the head of a sorted linked list, delete all duplicates such that each element appears only once. Return *the linked list sorted as well.\n 1 2 3 4 5 6 7 8  def solve(head): c = head while c and c.next: if c.val == c.next.val: c.next = c.next.next else: c = c.next return head   Remove Duplicates from Sorted List II (LC82)  Given the head of a sorted linked list, delete all nodes that have duplicate numbers, leaving only distict numbers from the original list. Return the linked list sorted as well.\n 1 2 3 4 5 6 7 8 9 10 11  def solve(head): c = dummy = ListNode(next=head) while head: while head.next and head.val == head.next.val: head = head.next if c.next == head: c.next = head.next else: c = c.next head = head.next return dummy.next   Remove Nth Node From End of List (LC19)  Given the head of a linked list, remove the nth node from the end of the list and return its head. Constaints: 0 \u003c n \u003c length of the list\n 1 2 3 4 5 6 7 8 9  def solve(head, n): c = dummy = ListNode(next = head) while head: if n \u003c= 0: c = c.next head = head.next n -= 1 c.next = c.next.next return dummy.next   ","description":"","tags":null,"title":"Remove Elements","uri":"/algorithms/linked-list/remove-elements/"},{"categories":null,"content":"Binary Tree Data Structure of the Node 1 2 3 4 5  class TreeNode: def __init__(self, val, left = None, right = None): self.val = val self.left = left self.right = right   Traversal 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56  def preorder(root): return [root.val] + preorder(root.left) + preorder(root.right) if root else [] def inorder(root): return inorder(root.left) + [root.val] + inorder(root.right) if root else [] def postorder(root): return postorder(root.left) + postorder(root.right) + [root.val] if root else [] def preorder(root: TreeNode) -\u003e List[int]: result = [] stack = [] while stack or root: if root: result.append(root.val) stack.append(root) root = root.left else: root = stack.pop().right return result def inorder(root: TreeNode) -\u003e List[int]: result = [] stack = [] while stack or root: if root: stack.append(root) root = root.left else: result.append(stack[-1].val) root = stack.pop().right return result def postorder(root: TreeNode) -\u003e List[int]: result = [] stack = [] while stack or root: if root: result.insert(0, root.val) stack.append(root) root = root.right else: root = stack.pop().right return result def bfs(root): result = [] queue = deque([root]) while queue: n = queue.popleft() result.append(n.val) # action point if n.left: queue.append(n.left) if n.right: queue.append(n.right) return result   ","description":"","tags":null,"title":"Binary Tree","uri":"/algorithms/binary-tree/binary-tree/"},{"categories":null,"content":"Word Ladder (LC127)  Given two words begin and end, and a dictionary words, return *the length of the shortest transformation sequence from begin to end, such that:\n Only one letter can be changed at a time. Each transformed word must exist in the word list.    Return 0 if there is no such transformation sequenece\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  def solve(begin, end, words): if end not in words: return 0 d = defaultdict(set) n = len(begin) for word in words: for i in range(n): d[word[0:i] + '?' + word[i+1:]].add(word) queue = deque([(begin, 1)]) seen = {begin} while queue: word, depth = queue.popleft() for i in range(n): for w in d[word[0:i] + '?' + word[i+1:]]: if end == w: return depth + 1 if w not in seen: seen.add(w) queue.append((w, depth + 1)) return 0   ","description":"","tags":null,"title":"Breadth First Search","uri":"/algorithms/breadth-first-search/breadth-first-search/"},{"categories":null,"content":"List Node 1 2 3 4  class ListNode: def __init__(self, val = 0, next = None): self.val = val self.next = next   ","description":"","tags":null,"title":"Linked List","uri":"/algorithms/linked-list/linked-list/"},{"categories":null,"content":"Missing Number(LC268)  Given any array nums containing n distinct numbers in the range[0, n],return the only number in the range that is missing from the array.\n Math 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  def solve_by_math(nums): ans = 0 for i, n in enumerate(nums): ans += i + 1 - n return ans def solve_by_bit(nums): ans = 0 for i, n in enumerate(nums): ans ^= i ^ n return ans def solve_by_set(nums): s = set(nums) for i in range(len(nums)): if i not in s: return i return len(nums) def solve_by_cycle(nums): i = 0 while i \u003c len(nums): j = nums[i] if j \u003c len(nums) and nums[j] != nums[i]: nums[i], nums[j] = nums[i], nums[j] else: i += 1 for i, x in enumerate(nums): if i != x: return i return len(nums)   Kth Missing Positive Number (LC1539)  Given an array nums of positive integers sorted in strictly increasing order, and an integer k. Find the kth positive integer that is missing from this array.\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  def solve_by_bisect(nums, k): start, end = 0, len(nums) while start \u003c end: mid = (start + end) // 2 if nums[mid] - mid - 1 \u003c k: start = mid + 1 else: end = mid return start + k def solve_by_set(nums, k): s = set(nums) for i in range(k + len(nums)): if k == 0: return i + 1 if i + 1 not in s: k -= 1   First Missing Positive (LC41)  Given an unsorted integer array nums, find the smallest missing positive integer.\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14  def solve_by_cycle(nums): n = len(nums) i = 0 while i \u003c n: j = nums[i] - 1 if j \u003c n and nums[i] != nums[j]: nums[i], nums[j] = nums[j], nums[i] else: i += 1 for i, x in enumerate(nums): if i + 1 != x: return i + 1 return len(nums) + 1   ","description":"","tags":null,"title":"Missing Number","uri":"/algorithms/array/missing-number/"},{"categories":null,"content":"One Edit Distance (bs32)  Given two string s and t determine whether they are one or zero edit distance away. An edit can be described as deleting a character, adding a character, or replacing a character with another character.\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  def solve(s, t): m, n = len(s), len(t) if abs(m - n) \u003e 1: return False if m == n: return sum(x != y for x, y in zip(s, t)) \u003c 2 i = j = k = 0 while k \u003c min(m, n): if s[i] != t[j]: if i != j: return False if m \u003e n: i += 1 else: j += 1 continue i, j, k = i + 1, j + 1, k + 1 return True   Edit Distance (lc72, bs117)  Given two strings s and t, find the minimum edit distance the two. One edit distance is defined as:\n Deleting a character or Inserting a character or Replacing a character.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  def solve(s, t): m, n = len(s) + 1, len(t) + 1 dp = [[0] * n for _ in range(m)] for i in range(m): dp[i][0] = i for j in range(n): dp[0][j] = j for i in range(1, m): for j in range(1, n): dp[i][j] = min( dp[i-1][j] + 1, # delete s[i-1] dp[i][j-1] + 1, # delete t[i-1], that is, adding for s dp[i-1][j-1] + (s[i-1] != t[j-1]) # replace s[i-1] with t[j-1] ) return dp[-1][-1]   ","description":"","tags":null,"title":"Edit Distance","uri":"/algorithms/dynamic-programming/edit-distance/"},{"categories":null,"content":"Longest Increasing Subsequence (lc300)  Given an integer array nums, return the length of the longest strictly increasing subsequence.\nA subsequence is a sequence that can be derived from an array by deleting some or no elements without changing the order of the remaining elements. For example, [3,6,2,7] is a subsequence of the array [0,3,1,6,2,2,7]\n 1 2 3 4 5 6 7 8 9 10  def solve(nums): if not nums: return 0 dp = [1 for _ in nums] for i range(1, len(nums)): for j in range(i): if nums[j] \u003c nums[i]: dp[j] = max(dp[i], 1 + dp[j]) return max(dp)   1 2 3 4 5 6 7 8 9  def solve(nums): dp = [0 for _ in nums] ans = 0 for x in nums: i = bisect_left(dp, x, hi=ans) dp[i] = x if ans == i: ans += 1 return ans   ","description":"","tags":null,"title":"Longest Increasing Subsequence","uri":"/algorithms/dynamic-programming/longest-increasing-subsequence/"},{"categories":null,"content":"Longest Common Subsequence (lc1143)  Given two strings s and t, return the length of their longest common subsequence. A subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters. (eg, “ace” is a subsequence of “abcde” while “aec” is not). A common subsequence of two strings is a subsequence that is common to both strings. If there is no common subsequence, return 0.\n 1 2 3 4 5 6 7 8  def solve_with_dfs(s, t): def dfs(s, t, i, j): if i == j == 0: return 0 if s[i-1] == t[j-1]: return 1 + dfs(s, t, i-1, j-1) return max(dfs(s, t, i-1, j), dfs(s, t, i, j-1)) return dfs(s, t, len(s), len(t))   1 2 3 4 5 6 7 8 9 10 11 12 13 14  def solve_with_dfs_memo(s, t): def dfs(s, t, i, j , memo): if i == j == 0: return 0 if memo[i][j] != -1: return memo[i][j] if s[i-1] == t[j-1]: memo[i][j] = 1 + dfs(s, t, i-1, j-1, memo) return memo[i][j] memo[i][j] = max(dfs(s, t, i-1, j, memo), dfs(s, t, i, j-1, memo)) return memo[i][j] memo = [[0] * len(t) for _ in s] return dfs(s, t, len(s), len(t), memo)   1 2 3 4 5 6 7  def solve(s, t): m, n = len(s) + 1, len(t) + 1 dp = [[0] * n for _ in range(m)] for i in range(1, m): for j in range(1, n): dp[i][j] = 1 + dp[i-1][j-1] if s[i-1] == t[j-1] else max(dp[i-1][j], dp[i][j-1]) return dp[-1][-1]   1 2 3 4 5 6 7 8  def solve(s, t): m, n = len(s) + 1, len(t) + 1 dp = [0] * n for i in range(1, m): prev = 0 for j in range(1, n): dp[j], prev = prev + 1 if s[i-1] == t[j-1] else max(dp[j], dp[j-1]), dp[j] return dp[-1]   ","description":"","tags":null,"title":"Longest Common Subsequence","uri":"/algorithms/dynamic-programming/longest-common-subsequence/"},{"categories":null,"content":"Check Array Formation Through Concatenation (LC1640)  Given an array of distinct integers arr and an array of integer arrays pieces, where the integers in pieces are distinct. Your goal is form arr by concatenating the arrays in pieces in any order. However, you are not allowed to reorder the integers in each array pieces[i].\nReturn true *if it is possible to form the array arr from pieces. Otherwise, return false.\n Intuition Because the arr’s integers and the pieces' integers are distinct, we can sort the integers of the pieces with the index of the arr’s integers. Then we join the sorted array and compare it.\nSolution 1 2 3  def solve(arr, pieces): d = {x: i for i, x in enumerate(arr)} return list(chain(*sorted(pieces, key=lambda x: d.get(x[0], 0)))) == arr   Find a Corresponding Node of a Binary Tree in a Clone of That Tree  Given two binary trees original and cloned and given a reference to a node target in the original tree. The cloned tree is copy of the original tree. Return *a reference to the same node in the cloned tree.\n Intuition Solution 1 2 3 4 5 6 7  def solve(original: TreeNode, cloned: TreeNode, target: TreeNode) -\u003e TreeNode: if not original: return None if original == target: return cloned return solve(origin.left, cloned.left, target) or solve(origin.right, cloned.right, target)   Beautiful Arrangement (LC526)  Suppose you have n integers from 1 to n. We define a beautiful arrangement as an array that is constructed by these n numbers successfully if one of the following is true for the ith position (1 \u003c= i \u003c= n) in this array:\n The number at the ith position is divisible by i. i is divisible by the number at the ith position.  Given an integer n, return the number of the beautiful arrangements that you can construct.\n Intuition Solution 1 2 3 4 5 6 7 8 9 10  def solve(n): def dfs(i, remainder): if i == 1: return 1 return sum( dfs(i - 1, remainder - {x}) for x in remainder if x % i == 0 or i % x == 0 ) return dfs(n, set(range(1, n+1)))   1 2 3 4 5 6 7 8 9 10 11 12 13 14  def solve(n): def dp(i, remainder, memo): if i == 1: return 1 if remainder in memo: return memo[remainder] memo[remainder] = sum( dp(i-1, remainder[:j] + remainder[j+1:], memo) for j in range(i) if remainder[j] % i == 0 or i % remainder[j] == 0 ) return memo[remainder] return dp(n, tuple(range(1, n+1)))   Merge Two Sorted Lists  Merge two sorted linked lists and return it as a sorted list. The list should be made by splicing together the nodes of the first two lists.\n Intuition Solution 1 2 3 4 5 6 7 8 9 10 11 12  def solve(a: ListNode, b: ListNode) -\u003e ListNode: c = dummy = ListNode() while a and b: if a.val \u003c b.val: c.next = a a = a.next else: c.next = b b = b.next c = c.next c.next = a or b return dummy.next   Remove Duplicates from Sorted List II  Given the head of a sorted linked list, delete all nodes that thave duplicate numbers, leaving only distinct numbers from the original list.\nReturn *the linked list sorted as well.\n Intuotion Solution 1 2 3 4 5 6 7 8 9 10 11  def solve(head: ListNode) -\u003e ListNode: c = dummy = ListNode(next=head) while head: if head.next and head.val == head.next.val: while head.next and head.val == head.next.val: head = head.next c.next = head.next else: c = c.next head = head.next return dummy.next   Kth Missing Positive Number  Given an array arr of positive integers sorted in a strictly increasing order, and an integer k.\nFind the kth positive integer that is missing from this array.\n Intuition Solution 1 2 3 4 5 6 7 8 9  def solve(arr: List[int], k: int) -\u003e int: start, end = 0, len(arr) while start \u003c end: mid = (start + end) // 2 if arr[mid] - mid \u003e k: end = mid else: start = mid + 1 return start + k   Longest Substring Without Repeating Characters  Given a string s, find the length of the longest substring without repeating characters.\n Intuition Solution 1 2 3 4 5 6 7 8 9 10  def solve(s: str) -\u003e int: seen = {} far = 0 result = 0 for i, c in enumerate(s): if c in seen: far = max(far, seen[c] + 1) result = max(result, i + 1 - far) seen[c] = i return result   ","description":"","tags":null,"title":"2021 January Week 1","uri":"/algorithms/challege/2021-january-week-1/"},{"categories":null,"content":"1710. Maximum Units on a Truck (LC1710)  You are assigned to put some amount of boxes onto one truck. You are give a 2D array boxTypes, where boxTypes[i] = [numberOfBoxes[i], numberOfUnitsPerBox[i]] Return the maximum total number of units that can be put on the truck.\n 1 2 3 4 5 6 7 8 9  def solve(boxes, truck): boxes.sort(key=lambda x: -x[1]) ans = 0 for s, t in boxes: if truck \u003c= s: return ans + truck * t ans += pick * t truck -= pick return ans   1711. Count Good Meals (LC1711)  A good meal is a meal that contains exactly two different food items with a sum of deliciousness equal to a power of two.\nYou can pick any two different foods to make a good meal. Given an array of integers deliciousness wher deliciousness[i] is the deliciousness of the ith item of food, return the number of different good meals you can make from this list modulo 10**9+7\nNote that items with different indices are considered different even if they have the sam deliciousness value.\n  Constraints:\n 1 \u003c= deliciousness.length \u003c= 10**5 0 \u003c= deliciousnedd[i] \u003c= 2**20   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  def solve(foods): MOD = 10**9 + 7 SHIFT = 22 counter = Counter(foods) keys = list(counter.keys()) ans = 0 for k in keys: v = counter[k] if k \u003e 0 and k \u0026 (k - 1) == 0: ans += v * (v - 1) // 2 % MOD del counter[k] for i in range(SHIFT): t = (1 \u003c\u003c i) - k if t in counter: ans += v * counter[t] % MOD return ans % MOD   1712. Ways to Split Array Into Three Subarrays (LC1712)  A split of an integer array is good if:\n The array is split into three non-empty contiguous subarrays - named left, mid, right respectively from left to right. The sum of the elements in left is less than or equal to the sum of the elements in mid, and the sum of the elements in mid is less than or equal to the sum of the elements in right.  Given nums, an array of non-negative integers, return the number of good ways to split nums. As the number may be too large, return it modulo 10**9 + 7.\n 1 2 3 4 5 6 7 8 9 10 11 12  def solve(nums): MOD = 10**9 + 7 n = len(nums) prefix = list(accumulate(nums)) ans = 0 for i in range(n - 2): start = bisect_left(prefix, prefix[i] * 2), lo=i+1) end = bisect_right(prefix, (prefix[i] + prefix[-1]) // 2, hi=n-1) if end \u003e start: ans += (end - start) % MOD return ans % MOD   1713. Minimum Operations to Make a Subsequence (LC1713)  You are given an array target that consists of distinct integers and another integer array arr that can have duplicates.\nIn one operation, you can insert any integer at any position in arr. For example, if arr = [1,4,1,2], you can add 3 in the middle and make it [1,4,3,1,2]. Note that you can insert the integer at the very beginning or end of the array.\nReturn the minimum number of operations needed to make target a subsequence of arr.\n 1 2 3 4 5 6 7 8 9 10  def solve(target, arr): nums = {x: i for i, x in enumerate(target)} piles = [] for x in arr: if x in nums: i = bisect_left(piles, nums[x]) if len(piles) == i: piles.append(0) piles[i] = nums[x] return len(target) - len(piles)   ","description":"","tags":null,"title":"Weekly Contest 222","uri":"/algorithms/contest/weekly-contest-222/"},{"categories":null,"content":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  class LetterTrieNode: def __init__(self): self.children = [None] * 26 self.word = False class Dict: def __init__(self): self.root = LetterTrieNode() def add(self, word): node = self.root for c in word: i = ord(c) - ord('a') if not node.children[i]: node.children[i] = LetterTrieNode() node = node.children[i] node.word = True def has(self, word): node = self._node(word) return node and node.word def startswith(self, prefix): return self._node(word) is not None def _node(self, word): node = self.root for c in prefix: i = ord(c) - ord('a') node = node.children[i] if not node: return None return node   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  class Trie: def __init__(self): self.__root = {} def add(self, word): node = self.__root for c in word: if c not in node: cur[c] = {} node = node[c] node['$'] = True def has(self, word): node = self.__root for c in prefix: if c not in node: return False node = node[c] return '$' in node def startswith(self, prefix): node = self.__root for c in prefix: if c not in node: return False node = node[c] return True   Map Sum Pairs  Implement the MapSum class:\n MapSum() initializes the MapSum object void insert(String key, int val) inserts the key-val pair into the map. If the key exists, the original value will be overriden to the new one. int sum(String prefix) returns the sum of all the pairs' value whose key starts with the prefix.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  class TrieNode: def __init__(self): self.children = defaultdict(TrieNode) self.val = 0 class MapSum: def __init__(self): self.root = TrieNode() self.seen = defaultdict(int) def insert(self, key, val): delta = val - self.seen[key] self.seen[key] = val node = self.root for c in key: node = node.children[c] node.val += delta def sum(self, prefix): node = self.root for c in prefix: node = node.children.get(c) if not node: return 0 return node.val   ","description":"","tags":null,"title":"Trie","uri":"/algorithms/trie/trie/"}]
