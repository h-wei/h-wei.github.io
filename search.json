[{"categories":["Algorithms","LeetCode"],"content":"Largest Rectangle in Histogram, LC84 Given an array of integers heights representing the histogram’s bar height where the width of each bar is 1, return the area of the largest rectangle in the histogramm.\nConstraints:  type: list[int] size: 1 \u003c= heights.length \u003c= 10**5 range: 0 \u003c= heights[i] \u003c= 10**4  Example:  Input: heights = [2,1,5,6,2,3], Output: 10 Input: heights = [2,4], Output: 4 Input: heights = [2,1,2], Output: 3  Intuition For given bar i with value h, how to find the biggest rectangle, which is ending with this bar? We need to find the previous smaller height which is less than or equal than h. For example, we’re at the 3rd place of [2,1,5,6,2,3], which height is 6, the previous small element is 5, which is at the 2nd place; we’re at the 4th place, which is 2 height, the previous samller element is the 1st element, that is 1. So, we might be use the monostack: which elements will be always in increasing order. And we iterate the list, when we hit an element is less than or equals than the last of the stack, then we pop the stack until the element is greater than the stack, and append the element to the stack.\nNote: It’s a nice method for adding two external empty element at two ends of the list.\nThat is O(n) space and time, where n is the length of the bars, because we use an external list and a monostack, and iterate the list and push/pop the stack.\nSolution 1 2 3 4 5 6 7 8 9 10  def largest_rectangle_histogram(heights: list[int]) -\u003e int: result = 0 stack = [] items = [0] + heights + [0] for i, v in enumerate(items): while stack and items[stack[-1]] \u003e h: h = items[stack.pop()] result = max(result, h * (i - stack[-1] - 1)) stack.append(i) return result   Maximal Rectangle, LC85 Given a row x cols binary matrix filled with 0’s and 1’s, find the largest retangle containing only 1’s and return is area.\nContraints:  type: list[list[str]] size: 0 \u003c= matrix.length, matrix[i].length \u003c= 200 range: matrix[i][j] == ‘0’ or ‘1’  Examples:  Input: [], Output: 0 Input: [[]], Output: 0 Input: [[“1”]], Output: 1 Input: [[“0”,“0”]], Output: 0 Input: [[“1”,“0”,“1”,“0”,“0”], [“1”,“0”,“1”,“1”,“1”], [“1”,“1”,“1”,“1”,“1”],[“1”,“0”,“0”,“1”,“0”]], Output: 6  Intuition Based the previous problemm, we can take the maximum of rectangle by layer one by one. We need to accumulate the layer one by one, where the element is “0”, the height of the bar will be set to 0.\nThere is O(n) space and O(m*n) time, where m is the length of the matrix, n is the length of the row of the matrix.\nSolution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  def max_rectangle(matrix: list[list[str]]) -\u003e int: if not matrix or not matrix[0]: return 0 layer = [0] * (len(matrix[0]) + 2) result = 0 for row in matrix: for i, c in enumerate(row): layer[i+1] = layer[i+1] + 1 if c == '1' else 0 stack = [] for i, l in enumerate(layer): while stack and layer[stack[-1]] \u003e l: h = layer[stack.pop()] result = max(result, h * (i - stack[-1] - 1)) stack.append(i) return result   ","description":"","tags":[],"title":"Largest Rectangle Histogram","uri":"/algorithms/2021/11/09/largest-rectangle-histogram/"},{"categories":["Algorithms","LeetCode"],"content":"Split Linked List in Parts, LC725 Given the head of a singly linked list and an integer k, split the linked list into k consecutive linked list parts.\nThe length of each part should be as equal as possible: no two parts should have a size differing by more than one. This may lead to some parts being null.\nThe parts should be in the order of occurrence in the input list, and parts occurring earlier should always have a size greatere than or eqaul to parts occurring later.\nReturn an array of the k parts.\nConstraints  The number of nodes in the list is in the range [0, 1000]. 0 \u003c= Node.val \u003c= 1000 1 \u003c= k \u003c= 50  Examples   Input: head = [1,2,3], k=5; Output: [[1], [2], [3]] Input: head = [1,2,3,4,5,6,7,8,9,10], k=3; Output: [[1,2,3,4], [5,6,7],[8,9,10]]   Solutions 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  def split_linked_list_to_parts(head: Optional[ListNode], k: int) -\u003e List[Optional[ListNode]]: n = 0 it = head while it: n, it = n+1, it.next mean, more = divmod(n, k) result = [None] * k prev = it = head for i in range(k): j = mean + (i \u003c more) result[j] = it while it and j: j, it, prev = j-1, it.next, it if prev: prev.next = None return result   ","description":"","tags":[],"title":"Split Linked List in Parts","uri":"/algorithms/2021/09/29/split-linked-list-in-parts/"},{"categories":["Algorithms","LeetCode"],"content":"","description":"","tags":[],"title":"Valid Triangle Number","uri":"/algorithms/2021/08/04/valid-triangle-number/"},{"categories":["Algorithms","LeetCode"],"content":"Find Eventual States, LC802 We start at some node in a directed graph, and every turn, we walk along a directed edge of the graph. If we reach a terminal node (that is, it has no outgoing directed edges), we stop.\nWe define a starting node to be safe if we must eventually walk to a terminal node. More specifically, there is a natural number k, so that we must have stopped at a terminal node in less than k steps for any choice of where to walk .\nReturn an array containing all the safe nodes of the graph. The answer should be sorted in ascending order.\nThe directed graph has n nodes with labels fr om0 to n-1, where n is the length of graph. The graph is given in the following form: graph[i] is a list of labels j such that (i,j) is a directed edge of the graph, going from node i to node j.\nConstraints  1 \u003c= graph.length \u003c= 10**4 0 \u003c= graph[i].length \u003c= graph.length graph[i] is sorted in a strictly increasing order. The graph may contain self-loops. The number o edges in the graph will be in the range [1, 4*10**4]  Examples   Input: graph =[[1,2],[2,3],[5],[0],[5],[],[]]; Output: [2,4,5,6] Input: graph = [[1,2,3,4],[1,2],[3,4],[0,4],[]]; Output: [4]   Solutions 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  def eventual_safe_nodes(graph: List[List[int]]) -\u003e List[int]: n = len(graph) neighbors = defaultdict(set) degrees = [0] * n for i, v in enumerate(graph): degrees[i] = len(v) for x in v: neighbors[x].add(i) queue = Deque([i for i, v in enumerate(degrees) if not v]) while queue: u = queue.popleft() for v in neighbors[u]: degrees[v] -= 1 if not degrees[v]: queue.append(v) return [i for i, v in enumerate(degrees) if not v]   1 2 3 4 5 6 7 8 9 10 11 12 13 14  def eventual_safe_nodes(graph: List[List[int]]) -\u003e List[int]: def safe(i: int) -\u003e bool: if color[i]: return color[i] == 2 color[i] = 1 for x in graph[i]: if not safe(x): return False color[i] = 2 return True n = len(graph) color = [0] * n return [i for i in range(n) if safe(i)]   ","description":"","tags":["Color","Graph"],"title":"Find Eventual States","uri":"/algorithms/2021/08/05/find-eventual-states/"},{"categories":["Algorithms","LeetCode"],"content":"Binary Tree Pruning, LC814 Given the root of a binary tree, return the same tree where every subtree (of the given tree) not containing a 1 has been removed.\nA subtree of a node node plus every node that is a descendant of node.\nConstraints  The number of nodes in the tree is in the range [1, 200] Node.val is either 0 or 1  Examples   Input: root = [1,null,0,0,1]; Output: [1,null,0,null,1] Input: root = []; Output: []   Solution 1 2 3 4 5 6  def prune_tree(root: TreeNode) -\u003e TreeNode: if not root: return None root.left, root.right = prune_tree(root.left), prune_tree(root.right) return root if root.left or root.right or root.val else None   ","description":"","tags":["Post-Order"],"title":"Binary Tree Pruning","uri":"/algorithms/2021/07/23/binary-tree-purning/"},{"categories":["Algorithms","LeetCode"],"content":"[Partition Array into Disjoint Intervals, LC] Given an array nums, partition it into two (contiguous) subarrays left and right so that:\n Every element in left is less than or equal to every element in right left and right are non-empty left has the smallest possible size  Constraints  2 \u003c= nums.length \u003c= 30000 0 \u003c= nums.length \u003c= 10**5 It is guaranteed there is at least one way to partition nums as describe.  Examples   Input: nums = [5,0,3,8,6]; Output: 3 Input: nums = [1,1,1,0,6,12]; Output: 4   Solution 1 2 3 4 5 6 7 8 9 10 11 12 13  def partition_disjoint(nums: List[int]) -\u003e int: n = len(nums) right = [0]*n + [float('inf')] for i in range(n-1, -1, -1): right[i] = min(nums[i], right[i-1]) upper = nums[0] i = 1 while i \u003c n and upper \u003e right[i]: upper = max(upper, nums[i]) i += 1 return i   1 2 3 4 5 6 7 8 9  def partition_disjoint(nums: List[int]) -\u003e int: result, temp, upper = 0, nums[0], nums[0] for i, x in enumerate(nums): if x \u003c temp: result = i temp = upper else: upper = max(upper, x) return result + 1   ","description":"","tags":[],"title":"Partition Array Into=disjoint Intervals","uri":"/algorithms/2021/07/22/partition-array-intodisjoint-intervals/"},{"categories":["Algorithms","LeetCode"],"content":"[Push Dominoes, LC] There are n dominoes in a line, and we place each domino vertically upright. In the beginning, we simultaneously push some of the dominoes either to the left or to the right.\nAfter each second, each domino that is falling to the left pushes the adjacent domino on the left. Similarly, the dominoes falling to the right push their adnacent dominoes standing on the right.\nWhen a vertical domino has dominoes falling on it from both sides, it stays still due to the balance of the forces.\nFor the purposes of this question, we will consider that a falling domino expends no additional force to a falling or already fallen domino.\nYou are given a string dominoes representing the initial state where:\n dominoes[i] = 'L', if the ith domino has been pushed to the left dominoes[i] = 'R', if the ith domino has been pushed to the right, and dominoes[i] = '.', if the ith domino has not been pushed.  Return a string representing the final state.\nConstraints  1 \u003c= dominoes.length \u003c= 10**5 dominoes[i] is either 'L', 'R', or '.'  Examples   Input: dominoes = “RR.L”; Output: “RR.L” Input: dominoes = “.L.R…LR..L..\"; Output: “LL.RR.LLRRLL..”   Solution 1  def push_dominoes(dominoes: str) -\u003e str:   ","description":"","tags":[],"title":"Push Dominoes","uri":"/algorithms/2021/07/21/push-dominoes/"},{"categories":["Algorithms","LeetCode"],"content":"Minimize Maximum Pair Sum in Array, LC1877 The pair sum of a pair (a, b) is equal to a + b. The maximum pair sum is the largest pair sum in a list of pairs.\n For example, if we have pairs (1,5), (2,3), and (4,4), the maximum pair sum would be max(1+5, 2+3, 4+4) = max(6,5,8) = 8  Given an array nums of even length n, pair up the elements of nums into n/2 pairs such that:\n Each element of nums is in exactly one pair, and The maximum pair sum is minimized.  Return the minimized maximum pair sum after optimally pairing up the elements.\nConstraints  2 \u003c= nums.length \u003c= 10**5 n is even 1 \u003c= nums[i] \u003c= 10**5  Examples   Input: nums = [3,5,2,3]; Output: 7 Input: nums = [3,5,4,2,4,6]; Output: 8   Solution 1 2 3  def min_pair_sum(nums: List[int]) -\u003e int: nums.sort() return max(nums[i] + nums[-1-i] for i in range(len(nums)//2))   ","description":"","tags":["Greedy"],"title":"Minimize Maximum Pair Sum in Array","uri":"/algorithms/2021/07/20/minimize-maximum-pair-sum-in-array/"},{"categories":["Algorithms","LeetCode"],"content":"Longest Palindromic Substring, LC5 Given a string s, return the longest palindromic substring in s.\nConstraints  1 \u003c= s.length \u003c= 1000 s consist of only digits and English letters  Examples   Input: s = “babad”; Output: “bab” Input: s = “a”; Output: “a”   Solution 1 2 3 4 5 6 7 8 9 10 11 12  def longest_palindrome(s: str) -\u003e str: def helper(start: int, end: int) -\u003e str: while -1 \u003c start and end \u003c n and s[start] == s[end]: start, end = start-1, end+1 return s[start+1:end] n = len(s) result = '' for i in range(n): result = max(result, helper(i-1, i+1), key=len) result = max(result, helper(i, i+1), key=len) return result   Longest Palindromic Subsequence, LC516 Given a string s, find the longest palindromic subsequence’s length in s.\nA subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements.\nConstraints  1 \u003c= s.length \u003c= 1000 s consists only of lowercase English letters  Examples   Input: s = “bbbab”; Output: 4 Input: s = “a”; Output: 1   Solution 1 2 3 4 5 6 7 8 9 10  def longest_palindrome_subsequence(s: str) -\u003e int: # f[i][j] = longest palindromic subsequence of s[i:j+1] # f[i][j] = 2 + f[i+1][j-1] if s[i]==s[j]. Where, the i element depends on the i+1 one, so we should iterate reversed. n = len(s) f = [[0] * n for _ in range(n)] for i in range(n-1, -1, -1): f[i][i] = 1 for j in range(i+1, n): f[i][j] = max(f[i+1][j], f[i][j-1]) if s[i] != s[j] else f[i+1][j-1] + 2 return f[0][-1]   ","description":"","tags":["DP","Palindrome"],"title":"Longest Palindromic Substring","uri":"/algorithms/2021/07/20/longest-palindromic-substring/"},{"categories":["Algorithms","LeetCode"],"content":"Frequency of the Most Frequent Element, LC1838 The frequency of an element is the number of times it occurs in an array.\nYou are given an integer array nums and an integer k. In one operation, you can choose an index of nums and increment the element at that index by 1.\nReturn the maximum possible frequency of an element after performing at most k operations.\nConstraints  1 \u003c= nums.length \u003c= 10**5 1 \u003c= nums[i] \u003c= 10**5 1 \u003c= k \u003c= 10**5  Examples   Input: nums = [1,2,4], k = 5; Output: 3 Input: nums = [1,4,8,13], k = 5; Output: 2   Solution 1 2 3 4 5 6 7 8 9  def max_frequency(nums: List[int], k: int) -\u003e int: nums.sort() i = 0 for j, x in enumerate(nums): k += x if k \u003c x * (j + 1 - i): k -= nums[i] i += 1 return j + 1 - i   ","description":"","tags":["Prefix Sum","Sliding Window"],"title":"Frequency of the Most Frequent Element","uri":"/algorithms/2021/07/19/frequency-of-the-most-frequent-element/"},{"categories":["Algorithms","LeetCode"],"content":"Minimum Path Sum, LC64 Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path.\nNote: You can only move either down or right at any point in time.\nConstraints  1 \u003c= grid.length, grid[i].length \u003c= 200 0 \u003c= grid[i][j] \u003c= 100  Examples   Input: grid = [[1,3,1],[1,5,1],[4,2,1]]; Output: 7 Input: grid = [[0]]; Output: 0   Solution 1 2 3 4 5 6 7 8 9 10  def min_path_sum(grid: List[List[int]]) -\u003e int: m, n = len(grid), len(grid[0]) f = grid[0][:] for j in range(1, n): f[j] += f[j-1] for i in range(1, m): f[0] += grid[i][0] for j in range(1, n): f[j] = grid[i][j] + min(f[j], f[j-1]) return f[-1]   Maximal Square, LC221 Given an m x n binary matrix filled with 0’s and 1’s, find the largest square containing only 1’s and return its area.\nConstraints  1 \u003c= matrix.length, matrix[i].length \u003c= 300 matrix[i][j] is '0' or '1'.  Examples   Input: matrix = [[“1”]]; Output: 1 Input: matrix = [[“0”,“1”], [“1”,“0”]]; Output: 1   Solution 1 2 3 4 5 6 7 8 9 10  def maximal_square(matrix: List[List[int]]) -\u003e int: m, n = len(matrix), len(matrix[0]) f = [[0] * n for _ in range(m)] for j in range(n): f[0][j] = 0 if matrix[0][j] == \"0\" else 1 for i in range(1, m): f[i][0] = 0 if matrix[i][0] == \"0\" else 1 for j in range(1, n): f[i][j] = 0 if matrix[i][j] == \"0\" else 1 + min(f[i-1][j-1], f[i-1][j], f[i][j-1]) return max(chain(*f)) ** 2   ","description":"","tags":["DP"],"title":"Minimum Path Sum","uri":"/algorithms/2021/07/19/minimum-path-sum/"},{"categories":["Algorithms","LeetCode"],"content":"Lowest Common Ancestor of a Binary Search Tree, LC235 Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST.\nAccording to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).\nConstraints  2 \u003c= nodes.length \u003c= 10**5 -10**9 \u003c= node.val \u003c= 10**9 All node.val are unique p != q p and q will exist in the BST.  Examples   Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8; Output: 6 Input: root = [2,1], p = 2, q = 1; Output: 2   Solution 1 2 3 4 5 6 7 8  def lowest_common_ancestor(root: TreeNode, p: TreeNode, q: TreeNode): while root: if p.val \u003c root.val and q.val \u003c root.val: root = root.left elif p.val \u003e root.val and q.val \u003e root.val: root = root.right else: return root   ","description":"","tags":["Binary Tree"],"title":"Lowest Common Ancestor of a Binary Search Tree","uri":"/algorithms/2021/07/19/lowest-common-ancestor-of-a-binary-search-tree/"},{"categories":["Algorithms","LeetCode"],"content":"Unique Paths, LC62 A robot is located at the top-left corner of a m x n grid.\nThe robot can only more either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid.\nHow many possible unique paths are there?\nConstrains  1 \u003c= m, n \u003c= 100 It’s guaranteed that the answer will be less than or equal 2 * 10**9.  Examples   Input: m = 1, n = 1; Output: 1 Input: m = 3, n = 2; Output: 3   Solution 1 2 3 4 5 6  def unique_paths(m: int, n: int) -\u003e int: f = [1] * n for _ in range(1, m): for i in range(1, n): f[i] += f[i-1] return f[-1]   Unique Paths II, LC63 A robot is located at the top-left corned of a m x n grid.\nThe robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid.\nNow consider if some obstacles are added to the grids. How many unique paths would there be?\nAn obstacle and space is marked as 1 and 0 respectively in the grid.\nConstraints  1 \u003c= grid.length, grid[i].length \u003c= 100 grid[i][j] is 0 or 1  Samples   Input: [[1]]; Output: 0 Input: [[0]]; Output: 1 Input: [[0,0,0],[0,1,0],[0,0,0]]; Output: 2   Solution 1 2 3 4 5 6 7 8 9 10 11 12  def unique_paths_with_obstacles(grid: List[List[int]]) -\u003e int: if grid[0][0] == 1 or grid[-1][-1] == 1: return 0 m, n = len(grid), len(grid[0]) f = [0] * n f[0] = 1 for i in range(m): f[0] = 0 if grid[i][0] else f[0] for j in range(1, n): f[j] = 0 if grid[i][j] else f[j] + f[j-1] return f[-1]   ","description":"","tags":["DP"],"title":"Unique Paths","uri":"/algorithms/2021/07/18/unique-paths/"},{"categories":["Algorithms","LeetCode"],"content":"Group Anagrams, LCCI10.02 Write a method to sort an array of strings so that all the anagrams are in the same group.\nConstraints Examples   Input: [“eat”, “tea”, “tan”, “ate”, “nat”, “bat”]; Output: [[“ate”,“eat”,“tea”],[“nat”,“tan”],[“bat”]]   Solution 1 2 3 4 5  def group_anagrams(strs: List[str]) -\u003e List[List[str]]: d = defaultdict(list) for s in strs: d[''.join(sorted(s))].append(s) return list(d.values())   ","description":"","tags":["Map","Sort"],"title":"Group Anagrams","uri":"/algorithms/2021/07/18/group-anagrams/"},{"categories":["Algorithms","LeetCode"],"content":"Reverse Nodes in K Group, LC25 Given a linked list, reverse the nodes of a linked list k at a time and return its modified list.\nk is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes, in the end, should remain as it is.\nYou many not alter the values in the list’s nodes, only nodes themselves may be changed.\nConstraints  1 \u003c= k \u003c= nodes.size \u003c= 5000 0 \u003c= node.val \u003c= 1000  Samples   Input: head = [1,2,3,4,5], k = 2; Output: [2,1,4,3,5] Input: head = [1,2,3,4,5], k = 1; Output: [1,2,3,4,5]   Solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14  def reverse_k_group(head: ListNode, k: int) -\u003e ListNode: if k == 1 or not head: return head size, it = 0, head while it: size, it = size+1, it.next it = dummy = ListNode(next = head) for _ in range(size // k): start, head = head, head.next for _ in range(1, k): it.next, start.next, head.next, head = head, head.next, it.next, head.next it = start return dummy.next   ","description":"","tags":["Linked List","Dummy"],"title":"Reverse Nodes in K Group","uri":"/algorithms/2021/07/18/reverse-nodes-in-k-group/"},{"categories":["Algorithms","LeetCode"],"content":"Three Equal Parts, LC927 You are given an array arr which consists of only zeros and ones, divide the array into three non-empty parts such that all of these parts represent the same binary value.\nIf it is possible, return any [i, j] with i+1 \u003c j, such that:\n arr[0:i+1] is the first part, arr[i+1:j] is the second part, arr[j:] is the third part All three parts have equal binary values.  If it is not possible, return [-1,-1]\nNote that the entire part is used when considering what binary value it represents. For example, [1,1,0] represents 6 in decimal, not 3. Also, leading zeros are allowed, so [0,1,1] and [1,1] represent the same value.\nConstraints  3 \u003c= arr.length \u003c= 3* 10**4 arr[i] is 0 or 1  Examples   Input: arr = [1,0,1,0,1]; Output: [0,3] Input: arr = [0,0,0,0,0]; Output: [0,4]   Solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  def three_equal_parts(arr: List[int]) -\u003e List[int]: ones = arr.count(1) unit, rem = divmod(ones, 3) if rem: return [-1, -1] n = len(arr) if ones == 0: return [0,n-1] third = ones = i = 0 while ones \u003c unit: third += arr[-1-i] \u003c\u003c i ones += arr[-1-i] i += 1 first = ones = i = 0 while ones \u003c= unit and first != third: first = (first \u003c\u003c 1) + arr[i] ones += arr[i] i += 1 if not (ones == unit and first == third): return [-1, -1] j = i second = ones = 0 while ones \u003c= unit and second != third: second = (second \u003c\u003c 1) + arr[j] ones += arr[j] j += 1 if not (ones == unit and second == third): return [-1, -1] return [i-1, j]   ","description":"","tags":["Iterate"],"title":"Three Equal Parts","uri":"/algorithms/2021/07/17/three-equal-parts/"},{"categories":["Algorithms","LeetCode"],"content":"Matrix Block Sum, LC1314 Given a m x n matrix mat and an integer k, return a matrix answer where each answer[i][j] is the sum of all elements mat[r][c] for:\n i - k \u003c= r \u003c= i + k, j - k \u003c= c \u003c= j + k, and (r, c) is a valid position in the matrix.  Constraints  1 \u003c= matrix.length, matrix[i].length, k \u003c= 100 1 \u003c= matrix[i][j] \u003c= 100  Examples   Input: mat = [[1,2,3],[4,5,6],[7,8,9]], k = 1; Output: [[12,21,16],[27,45,33],[24,39,28]] Input: mat = [[1,2,3],[4,5,6],[7,8,9]], k = 2; Output: [[45,45,45],[45,45,45],[45,45,45]]   Solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14  def matrix_block_sum(matrix: List[List[int]], k: int) -\u003e List[List[int]]: m, n = len(matrix), len(matrix[0]) f = [[0] * (n+1) for _ in range(m+1)] for i in range(1, m+1): for j in range(1, n+1): f[i][j] = matrix[i-1][j-1] + f[i-1][j] + f[i][j-1] - f[i-1][j-1] result = [[0] * n for _ in range(m)] for i in range(m): x0, x1 = max(0, i-k), min(m-1, i+k)+1 for j in range(n): y0, y1 = max(0, j-k), min(n-1, j+k)+1 result[i][j] = f[x1][y1] + f[x0][y0] - f[x1][y0] - f[x0][y1] return result   [Range Sum Query 2D - Immutable] Given a 2D matrix matrix, handle multiple queries of the following type:\n Calculate the sum of the elements of matrix inside the rectangle defined by its upper left corner (row1, col1) and lower right corner (row2, col2).  Implement the NumMatrix class:\n NumMatrix(int[][] matrix) Initializes the object with the integer matrix matrix` int sum_region(int row1, int col1, int row2, int col2) Returns the sum of the elements of matrix inside the rectangle defined by its upper left corner (row1, col1) and lower right corner (row2, col2)  Constraints  1 \u003c= matrix.length, matrix[i].length \u003c= 200 -10**5 \u003c= matrix[i][j] \u003c= 10**5 0 \u003c= row1 \u003c= row2 \u003c= m 0 \u003c= col1 \u003c= col2 \u003c= n  Examples   Input: [“NumMatrix”, “sum_region”, “sum_region”, “sum_region”] [[[[3, 0, 1, 4, 2], [5, 6, 3, 2, 1], [1, 2, 0, 1, 5], [4, 1, 0, 1, 7], [1, 0, 3, 0, 5]]], [2, 1, 4, 3], [1, 1, 2, 2], [1, 2, 2, 4]]; Output: [null, 8, 11, 12]   Solution 1 2 3 4 5 6 7 8 9 10  class NumMatrix: def __init__(self, matrix: List[List[int]]): m, n = len(matrix), len(matrix[0]) self.f = [[0] * (n+1) for _ in range(m+1)] for i in range(1, m+1): for j in range(1, n+1): self.f[i][j] = matrix[i-1][j-1] + self.f[i-1][j] + self.f[i][j-1] - self.f[i-1][j-1] def sum_region(self, row1: int, col1: int, row2: int, col2: int) -\u003e int: return self.f[row2+1][col2+1] + self.f[row1][col1] - self.f[row2+1][col1] - self.f[row1][col2+1]   ","description":"","tags":[],"title":"Matrix Block Sum","uri":"/algorithms/2021/07/17/matrix-block-sum/"},{"categories":["Algorithms","LeetCode"],"content":"4 Sum, LC18 Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:\n 0 \u003c= a,b,c,d \u003c n a, b, c, and d are distinct nums[a] + nums[b] + nums[c] + nums[d] == target.  You may return the answer in any order.\nConstraints  1 \u003c= nums.length \u003c= 200 -10**9 \u003c= nums[i] \u003c= 10**9 -10**9 \u003c= target \u003c= 10**9  Examples   Input: nums = [1,0,-1,0,-2,2], target = 0; Output: [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]] Input: nums = [2,2,2,2,2], target = 8; Output: [[2,2,2,2]]   Solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  def four_sum(nums: List[int], target: int) -\u003e int: nums.sort() n, result = len(nums), set() for i in range(n-3): for j in range(i+1, n-2): x = target - nums[i] - nums[j] s, e = j+1, n-1 while s \u003c e: if nums[s] + nums[e] == x: result.add((nums[i], nums[j], nums[s], nums[e])) s, e = s+1, e-1 elif nums[s] + nums[e] \u003e x: e -= 1 else: s += 1 return [list(item) for item in result]   1 2 3 4 5 6 7 8 9 10 11 12  def four_sum(nums: List[int], target: int) -\u003e int: n, result = len(nums), set() for i in range(n-3): for j in range(i+1, n-2): x = target - nums[i] - nums[j] s = set() for k in range(j+1, n): if nums[k] in s: result.add(tuple(sorted(nums[i], nums[j], nums[k], x-nums[k]))) else: s.add(x - nums[k]) return [list(item) for item in result]   ","description":"","tags":["Sort","Two Pointers","Set"],"title":"4 Sum","uri":"/algorithms/2021/07/16/4-sum/"},{"categories":["Algorithms","LeetCode"],"content":"Minimum Falling Path Sum, LC931 Given an n x n array of integers matrix, return the minimum sum of any falling path through matrix.\nA falling path starts at any element in the first row and chooses the element in the next row that is either directly below or diagonally left/right. Specifically, the next element from position (row, col) will be (row+1, col-1), (row+1, col) or (row+1, col+1).\nConstraints  1 \u003c= matrix.length == matrix[i].length \u003c= 100 -100 \u003c= matrix[i][j] \u003c= 100  Examples   Input: matrix = [[2,1,3],[6,5,4],[7,8,9]]; Output: 13 Input: matrix = [[-48]]; Output: -48   Solution 1 2 3 4 5 6 7 8 9 10 11  def min_falling_path_sum(matrix: List[List[int]]) -\u003e int: n = len(matrix) for i in range(1, n): for j in range(n): temp = matrix[i-1][j] if j \u003e 0: temp = min(temp, matrix[i-1][j-1]) if j \u003c n-1: temp = min(temp, matrix[i-1][j+1]) matrix[i][j] += temp return min(matrix[-1])   Triangle, LC120 Given a triangle array, return the minimum path sum from top to bottom.\nFor each step, you may move to an adjacent number of the row below. More formally, if you are on index i on the current now, you may move to either index i or index i+1 on the next row.\nConstraints  1 \u003c= triangle.length \u003c= 200 triangle[0].length == 1 triangle[i].length == triangle[i-1].length + 1 -10**4 \u003c= triangle[i][j] \u003c= 10**4  Examples   Input: triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]; Output: 11 Input: triangle = [[-10]]; Output: -10   Solution 1 2 3 4 5 6  def minimum_total(triangle: List[List[int]]) -\u003e int: n = len(triangle) for i in range(n-2, 0, -1): for j in range(i+1): triangle[i][j] += min(triangle[i+1][j], triangle[i+1][j+1]) return triangle[0][0]   ","description":"","tags":["DP"],"title":"Minimum Falling Path Sum","uri":"/algorithms/2021/07/16/minimum-falling-path-sum/"},{"categories":["Algorithms","LeetCode"],"content":"Find First and Last Position of Element in Sorted Array, LC34 Given an array of integers nums sorted in ascending order, find the starting and ending position of a given target value.\nIf target is not found in the array, return [-1,-1].\nYou must write an algorithm with O(log n) runtime complexity.\nConstraints  0 \u003c= nums.length \u003c= 10**5 -10**9 \u003c= nums[i] \u003c= 10**9 nums is a ascending array. -10**9 \u003c= nums[i] \u003c= 10**9  Examples   Input: nums = [5,7,7,8,8,10], target = 8; Output: [3,4] Input: nums = [5,7,7,8,8,10], target = 6; Output: [-1,-1] Input: nums = [], target = 0; Output: [-1,-1]   Solution 1 2 3 4 5 6  def search_range(nums: List[int], target: int) -\u003e List[int]: first, last = bisect_left(nums, target), bisect_right(nums, target) return [ first if first \u003c len(nums) and nums[first] == target else -1, last-1 if last \u003e 0 and nums[last] == target else -1 ]   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  def search_range(nums: List[int], target: int) -\u003e List[int]: def bi_first(nums: List[int], target: int) -\u003e int: s, e = 0, len(nums) while s \u003c e: m = (s + e) // 2 if nums[m] \u003c target: s = m + 1 else: e = m return s if s \u003c len(nums) and nums[s] == target else -1 def bi_last(nums: List[int], target: int) -\u003e int: s, e = 0, len(nums) while s \u003c e: m = (s + e) // 2 if nums[m] \u003e target: e = m else: s = m + 1 return s-1 if s \u003e 0 and nums[s-1] == target else -1 return [bi_first(nums, target), bi_last(nums, target)]   ","description":"","tags":["Binary Search"],"title":"Find First and Last Position of Element in Sorted Array","uri":"/algorithms/2021/07/16/find-first-and-last-position-of-element-in-sorted-array/"},{"categories":["Algorithms","LeetCode"],"content":"Maximum Element After Decreasing and Rearranging, LC1846 You are given an array of positive integers arr. Perform some operations (possibly none) on arr so that it satisfies these conditions:\n The value of the first element in arr must be 1. The absolute difference between any 2 adjacent elements must be less than or equal to 1.  There are 2 types of operations that you can perform any number of times:\n Decrease the value of any element of arr to a smaller positive integer. Rearrange the elements of arr to be in any order.  Return the maximum possible value of an element in arr after performing the operations to satisfy the conditions.\nConstraints  1 \u003c= arr.length \u003c= 10**5 1 \u003c= arr[i] \u003c= 10**9  Examples   Input: arr = [2,2,1,2,1]; Output: 2 Input: arr = [1,2,3,4,5]; Output: 5   Solution 1 2 3 4 5 6 7  def max_element(arr: List[int]) -\u003e int: arr.sort() result = 0 for x in arr: if x \u003e result: result += 1 return result   ","description":"","tags":["Sort","Greedy"],"title":"Maximum Element After Decreasing and Rearranging","uri":"/algorithms/2021/07/15/maximum-element-after-decreasing-and-rearranging/"},{"categories":["Algorithms","LeetCode"],"content":"Valid Triangle Number, LC611 Given an integer array nums, return the number of triplets chosen from the array that can make triangles if we take them as side lengths of a triangle.\nConstraints  1 \u003c= nums.length \u003c= 1000 0 \u003c= nums[i] \u003c= 1000  Examples   Input: nums = [2,2,3,4]; Output: 3 Input: nums = [4,2,3,4]; Output: 4   Solution 1 2 3 4 5 6 7 8 9 10 11 12  def valid_triangle_number(nums: List[int]) -\u003e int: nums.sort() n, result = len(nums), 0 for k in range(2, n): i, j = 0, i-1 while i \u003c j: if nums[i] + nums[j] \u003e nums[k]: result += j - i j -= 1 else: i += 1 return result   ","description":"","tags":["Sort","Two Pointers"],"title":"Valid_triangle_number","uri":"/algorithms/2021/07/15/valid_triangle_number/"},{"categories":["Algorithms","LeetCode"],"content":"Pascal’s Triangle, LC118 Given an integer numRows, return the first numRows of Pascal’s triangle.\nIn Pascal’s triangle, each number is the sum of the two numbers directly above it as shown.\nConstraints  1 \u003c= numRows \u003c= 30  Examples   Input: numRows = 5; Output: [[1],[1,1],[1,2,],[1,3,3,1],[1,4,6,4,1]] Input: numRows = 1; Output: [[1]]   Solution 1 2 3 4 5 6 7 8  def pascals_triangle(row : int) -\u003e List[List[int]]: result = [[1]] for _ in range(1, row): temp = [0] + result[-1] for i, x in enumerate(result[-1]): temp[i] += x result.append(temp) return result   1 2  def pascals_triangle(row: int) -\u003e List[List[int]]: return [[comb(i, j) for j in range(i+1)] for i in range(row)]   Pascal’s Triangle II, LC119 Given an integer rowIndex, return the rowIndexth row of the Pascal’s triangle.\nIn Pascal’s triangle, each number is the sum of the two numbers directly above it as shown.\nConstraints  0 \u003c= rowIndex \u003c= 33  Examples   Input: rowIndex = 3; Output: [1,3,3,1] Input: rowIndex = 0; Output: [1]   Solution 1 2  def pascals_triangle(rowIndex: int) -\u003e List[List[int]]: return [comb(rowIndex, i) for i in range(rowIndex+1)]   1 2 3 4 5 6  def pascals_triangle(rowIndex: int) -\u003e List[List[int]]: result = [1] * (rowIndex + 1) for i in range(rowIndex + 1): for j in range(i-1,0,-1): result[j] += result[j-1] return result   ","description":"","tags":["DP","Math"],"title":"Pascal’s Triangle","uri":"/algorithms/2021/07/15/pascals-triangle/"},{"categories":["Algorithms","LeetCode"],"content":"Ugly Number II, LC264 An ugly number is a positive integer whose prime factors are limited to 2, 3 and 5.\nGiven an integer n, return the nth ugly number.\nConstraints  1 \u003c= n \u003c= 1690  Examples   Input: n = 10; Output: 12 Input: n = 1; Output: 1   Solution 1 2 3 4 5 6 7 8 9 10 11 12  def nth_ugly_number(n: int) -\u003e int: f = [1] * n p2 = p3 = p5 = 0 for i in range(1, n): f[i] = min(f[p2]*2, f[p3]*3, f[p5]*5) if f[i] == f[p2]*2: p2 += 1 if f[i] == f[p3]*3: p3 += 1 if f[i] == f[p5]*5: p5 += 1 return f[-1]   Unique Binary Search Trees, LC96 Given an integer n, return the number of structurally unique binary search trees which has exactly n nodes of unique values from 1 to n.\nConstraints  1 \u003c= n \u003c= 19  Examples   Input: 1; Output: 1 Input: 2; Output: 2 Input: 3; Output: 5   Solution 1 2 3 4 5 6  def num_trees(n: int) -\u003e int: f = [1] + [0]*n f[1] = 1 for i in range(2, n+1): f[i] = sum(f[j] * f[i-1-j] for j in range(i)) return f[-1]   ","description":"","tags":["DP"],"title":"Ugly Number II","uri":"/algorithms/2021/07/14/ugly-number-ii/"},{"categories":["Algorithms","LeetCode"],"content":"Custom Sort String, LC791 order and s are strings composed of lowercase letters. In order, no letter occurs more than once.\norder was sorted in some custom order previously. We want to permute the characters of s so that they match the order that order was sorted. More specifically, if x occurs before y in order, then x should occur before y in the returned string.\nReturn any permutation of s that satisfies property.\nConstraints  order has length at most 26, and no character is repeated in order. s has length at most 200 order and s consist of lowercase letters only.  Examples   Input: order = “cba”, s = “abcd”; Output: “cbad”   Solution 1 2 3  def custom_sort_string(order: str, s: str) -\u003e str: t = {c: i for i, c in enumerate(order)} return ''.join(sorted(list(s), key = lambda c: t.get(c, 26)))   1 2 3  def custom_sort_string(order: str, s: str) -\u003e str: count = Counter(list(s)) return ''.join(c * count[c] for c in order) + ''.join(c * v for c, v in count.items() if c not in order)   ","description":"","tags":["Sort"],"title":"Custom Sort String","uri":"/algorithms/2021/07/14/custom-sort-string/"},{"categories":["Algorithms","LeetCode"],"content":"Minimum Absolute Sum Difference, LC1818 You are given two positive integer arrays nums1 and nums2, both of length n.\nThe absolute sum difference of arrays nums1 and nums2 is defined as the sum of |nums1[i] - nums2[i]| for each 0 \u003c= i \u003c n (0-indexed)\nYou can replace at most one element of nums1 with any other element in nums1 to minimize the absolute sum difference.\nReturn the minimum absolute sum difference after replacing at most one element in the array nums1. Since the answer may be large, return it modulo 10**9 + 7\nConstraints  1 \u003c= nums1.length == num2.length \u003c= 10**5 1 \u003c= nums1[i], nums2[i] \u003c= 10**5  Examples   Input: nums1 = [1,7,5], nums2 = [2,3,5]; Output: 3 Input: nums1 = [2,4,6,8,10], nums2 = [2,4,6,8,10]; Output: 0 Input: nums1 = [1,10,4,4,2,7], nums2 = [9,3,5,1,7,4]; Output: 20   Solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  def min_absolute_sum_diff(nums1: List[int], nums2: List[int]) -\u003e int: MOD, n, result = 10**9 + 7, len(nums1), 0 for x, y in zip(nums1, nums2): result += abs(x - y) % MOD if result == 0: return 0 nums = sorted(nums1) mod = 0 for i, x in enumerate(nums2): left = bisect_left(nums, x) if left \u003c n: mod = max(mod, abs(x-nums1[i]) - (nums[left-1] -x )) if left \u003e 0: mod = max(mod, abs(x-nums1[i]) - (x - nums[left])) return (result - mod) % MOD   ","description":"","tags":["Binary Search"],"title":"Minimum Absolute Sum Difference","uri":"/algorithms/2021/07/14/minimum-absolute-sum-difference/"},{"categories":["Algorithms","LeetCode"],"content":"Arithmetic Slices, LC413 An integer array is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.\n For example, [1,3,5,7,9], [7,7,7,7] and [3,-1,-5,-9] are arithmetic sequences.  Given an integer array nums, return the number of arithmetic subarrays of nums.\nConstraints  1 \u003c= nums.length \u003c= 5000 -1000 \u003c= nums[i] \u003c= 1000  Examples   Input: nums = [1,2,3,4]; Output: 3 Input: nums = [1]; Output: 0   Solution 1 2 3 4 5 6 7 8 9  def num_of_arithmetic_slices(nums: List[int]) -\u003e int: n, result, temp = len(nums), 0, 0 for i in range(1, n-1): if nums[i] * 2 != nums[i-1] + nums[i+1]: result += (temp + 1) * temp // 2 temp = 0 else: temp += 1 return result + (temp + 1) * temp // 2   ","description":"","tags":["Math"],"title":"Arithmetic Slices","uri":"/algorithms/2021/07/13/arithmetic-slices/"},{"categories":["Algorithms","LeetCode"],"content":"The Skyline Problem, LC218 A city’s skyline is the outer contour of the silhouette formed by all the buildings in that city when viewed from a distance. Given the locations and heights of all the buildings, return the skyline formed by these buildings collectively.\nThe geometric information of each building is given in the array buildings where buildings[i] = [left_i, right_i, height_i]:\n left_i is the x coordinate of the left edge of the ith building. right_i is the x coordinate of the right edge of the ith building. height_i is the height of the ith building.  You may assume all buildings are perfect rectangles grounded on an absolutely flat surface at height 0.\nNote:\n the skyline is sorted by their x-coordinate. there are no the same height at the consecutive lines.  Constraints  1 \u003c= buildings.length \u003c= 10**4 0 \u003c= left \u003c right \u003c 2*31 - 1 1 \u003c= height \u003c= 2**31 - 1 buildings is sorted by left in non-decreasing order  Examples   Input: buildings = [[2,9,10],[3,7,15],[5,12,12],[15,20,10],[19,24,8]]; Output: [[2,10],[3,15],[7,12],[12,0],[15,10],[20,8],[24,0]] Input: buildings = [[0,2,3],[2,5,3]]; Output: [[0,3],[5,0]]   Solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  def get_skylines(buildings: List[List[int]]) -\u003e List[List[int]]: \"\"\" [2,9,10],[3,7,15],[5,12,12] [2,-10,9],[3,-15,7],[5,-12,12],[7,0,0],[9,0,0],[12,0,0] \"\"\" xs = [] for start, end, height in buildings: xs.append((start, -height, end)) xs.append((end, 0, None)) result = [[-1,0]] heap = [(0, float('inf'))] for start, h, end in sorted(xs): while start \u003e= heap[0][1]: heappop(heap) if h \u003c 0: heappush(heap, (h, end)) if result[-1][1] != -hp[0][0]: result.append((x, -h)) return result[1:]   ","description":"","tags":["Line Sweep","Heap"],"title":"The Skyline Problem","uri":"/algorithms/2021/07/13/the-skyline-problem/"},{"categories":["Algorithms","LeetCode"],"content":"Find Peak Element, LC162 A peak element is an element that is strictly greater than its neighbors.\nGiven an integer array nums, find a peak element, and return its index. If the array contains multiple peaks, return the index to any of the peaks.\nYou may imagine that nums[-1] = nums[n] = -inf.\nYou must write an algorithm that runs in O(log n) time.\nConstraints  1 \u003c= nums.length \u003c= 1000 -2**31 \u003c= nums[i] \u003c= 2**31 - 1 nums[i] != nums[i+1] for all valid i  Examples   Input: nums = [1,2,3,1]; Output: 2 Input: nums = [1,2,1,3,5,6,4]; Output: 5   Solution 1 2 3 4 5 6 7 8 9  def find_peak_element(nums: List[int]) -\u003e int: start, end = 0, len(nums)-1 while start \u003c end: mid = (start + end) // 2 if nums[mid] \u003e nums[mid+1]: end = mid else: start = mid + 1 return start   ","description":"","tags":["Binary Search"],"title":"Find Peak Element","uri":"/algorithms/2021/07/13/find-peak-element/"},{"categories":["Algorithms","LeetCode"],"content":"Isomorphic Strings, LC205 Given two strings s and t, determine if they are isomorphic.\nTwo strings s and t are isomorphic if the characters in s can be replaced to get t.\nAll occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the sae character, but a character may map to itself.\nConstraints  1 \u003c= s.length \u003c= 5 * 10**4 s.length = t.length s and t consist of any valid ascii character.  Examples   Input: s = “egg”, t = “add”; Output: true Input: s = “foo”, t = “bar”; Output: false Input: s = “paper”, t = “title”; Output: true   Solution 1 2 3 4 5 6 7 8 9 10  def is_isomorphic(s: str, t: str) -\u003e bool: f = {} for i, j in zip(s, t): if i not in f: if j in f.values(): return False f[i] = j elif j != f[i]: return False return True   1 2  def is_isomorphic(s: str, t: str) -\u003e bool: return len(set(s)) == len(set(t)) == len(set(zip(s, t)))   ","description":"","tags":["Set"],"title":"Isomorphic Strings","uri":"/algorithms/2021/07/12/isomorphic-strings/"},{"categories":["Algorithms","LeetCode"],"content":"Word Break, LC139 Given a string s and a dictionary of strings wordDict, return true if s can be segmented into a space-separated sequence of one or more dictionary words.\nNote that the same word in the dictionary may be reused multiple times in the segmentation.\nConstraints  1 \u003c= s.length \u003c= 300 1 \u003c= wordDict.length \u003c= 1000 `1 \u003c= wordDict[i].length \u003c= 20 s and wordDict[i] consist of only lowercase English letters. All the strings of wordDict are unique.  Examples   Input: s = “catsandog”, wordDict = [“cats”, “dog”, “sand”, “and”, “cat”]; Output: false Input: s = “applepenapple”, wordDict = [“apple”, “pen”]; Output: true   Solution 1 2 3 4 5 6 7 8 9 10 11 12 13  def word_break(s: str, wordDict: List[str]) -\u003e bool: words = set(wordDict) m, n = min(len(w) for w in words), max(len(w) for w in words) f = [1] + [0] * len(s) for i in range(1, len(f)): if f[i-1] == 1: for j in range(m, n+1): t = s[i-1:i-1+j] if t in words: f[i-1+j] = 1 if f[-1]: return True return False   1 2 3 4 5 6 7 8 9 10 11  def word_break(s: str, wordDict: List[str]) -\u003e bool: words = set(wordDict) m, n = min(len(w) for w in words), max(len(w) for w in words) tries = {0} seen = {0} while tries: tries = {x + i for x in tries for i in range(m, n+1) if s[x:x+i] in words} - seen seen |= tries if len(s) in tries: return True return False   Trapping Rain Water, LC42 Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.\nConstraints  0 \u003c= height.length \u003c= 3 * 10**4 0 \u003c= height[i] \u003c= 10**5  Examples   Input: height = [0,1,0,2,0,1,3,2,1,2,1]; Output: 6 Input: height = [4,2,0,3,2,5]; Output: 9   Solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  def trap(height: List[int]) -\u003e int: if not height: return 0 start, end = 0, len(height) - 1 max_s, max_e = height[start], height[end] result = 0 while start \u003c end: if height[start] \u003c height[end]: result += max_s - height[start] start += 1 max_s = max(max_s, height[start]) else: result += max_e - height[end] end -= 1 max_e = max(max_e, height[end]) return result   ","description":"","tags":["BFS","DP","Left-Right Pass"],"title":"Word Break","uri":"/algorithms/2021/07/12/word-break/"},{"categories":["Algorithms","LeetCode"],"content":"H-Index II, LC 275 Given an array of integers citations where citations[i] is the number of citations a researcher received for their ith paper and citations is sorted in an ascending order, return compute the researcher’s h-index.\nIf there are several possible values for h, the maximum one is taken as the h-index.\nConstraints:  1 \u003c= citations.length \u003c= 10**5 0 \u003c= citations[i] \u003c= 1000 citations is sorted in ascending order.  Examples   Input: citations = [0,1,3,5,6]; Output: 3 Input: citations = [1,2,100]; Output: 2   Solution 1 2 3 4 5 6 7 8 9 10  def h_index(citations: List[int]) -\u003e int: n = len(citations) start, end = 0, n while start \u003c end: mid = (start + end) // 2 if citations[mid] \u003c n - mid: start = mid + 1 else: end = mid return n - start   ","description":"","tags":["Binary Search","Two Pointers","DP"],"title":"H Index II","uri":"/algorithms/2021/07/12/h-index-ii/"},{"categories":["Algorithms","LeetCode"],"content":"Best Time to Buy and Sell Stock with Cooldown, LC309 You are given an array prices where prices[i] is the price of a given stock on the ith day.\nFind the maximum profit you can achieve. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times) with the following restrictions:\n After you sell your stock, you cannot buy stock on the next day (i.e., cooldown one day)  Note: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).\nConstraints:  1 \u003c= prices.length \u003c= 5000 0 \u003c= prices[i] \u003c= 1000  Example:   Input: prices = [1,2,3,0,2]; Output: 3 Input: prices = [1]; Output: 0   Solution: 1 2 3 4 5  def max_profit(prices: List[int]) -\u003e int: buy, sell, cool = -prices[0], 0, 0 for x in prices: buy, sell, cool = max(buy, cool-x), x+buy, max(sell, cool) return max(sell, cool)   Best Time to Buy and Sell Stock with Transaction Fee, LC714 You are given an array prices where prices[i] is the price of a given stock on the ith day, and an integer fee representing a transaction fee.\nFind the maximum profit you can achieve. You may complete as many transactions as you like, but you need to pay the transaction fee for each sell.\nNote: you may not engage in multiple transactions simultaneously.\nConstraints  1 \u003c= prices.length \u003c= 5 * 10**4 1 \u003c= prices[i] \u003c 5 * 10**4  Example   Input: prices = [1,3,2,8,4,9], fee = 2; Output: 8 Input: prices = [1,3,7,5,10,3], fee = 3; Output: 6   Solution 1 2 3 4 5  def max_profit(prices: List[int]) -\u003e int: buy, sell = -prices[0], 0 for x in prices: buy, sell = max(buy, sell-x), max(sell, x+buy) return sell   ","description":"","tags":["DP"],"title":"Best Time to Buy and Sell Stock with Cooldown","uri":"/algorithms/2021/07/11/best-time-to-buy-and-sell-stock-with-cooldown/"},{"categories":["Algorithms","LeetCode"],"content":"H-Index, LC274 Given an array of integers citations where citations[i] is the number of citations a researcher received for their ith paper, return compute the researcher’s h-index.\nAccording to the definition of h-index on Wikipedia: A scientist has an index h if h of their n papers have at least h citations each, and the other n-h papers have no more than h citations each.\nIf there are several possible values for h, the maximum one is taken as the h-index.\nConstraints:  1 \u003c= citations.length \u003c= 5000 0 \u003c= citations[i] \u003c= 1000  Example:   Input: citations = [3,0,6,1,5]; Output: 3 Input: citations = [1,3,1]; Output: 1   Solution: 1 2 3 4 5  def h_index(citations: List[int]) -\u003e int: for i, c in enumerate(sorted(citations, reverse = True)): if i + 1 \u003e c: return i return len(citations)   ","description":"","tags":["Sort"],"title":"H Index","uri":"/algorithms/2021/07/11/h-index/"},{"categories":["Algorithms","LeetCode"],"content":"Find Median From Data Stream, LC295 The median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value and the median is the mean of the two middle values.\nImplement the MedianFinder class:\n MedianFinder() initializes the MedianFinder object. void addNum(int num) adds the integer num from the data stream to the data structure double findMedian() returns the median of all elements so far.  Constraints:  -10**5 \u003c= num \u003c= 10**5 There will be at least one element in the data structure before calling findMedian At most 5 * 10**4 calls will be made to addNum and findMedian.  Example:   Input: [“MedianFinder”, “addNum”, “addNum”, “findMedian”, “addNum”, “findMedian”] [[],[1],[2],[],[3],[]]; Output: [null, null, null, 1.5, null, 2.0]   Solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  class MedianFinder: def __init__(self): self._lower = [] self._upper = [] def add(self, num: int) -\u003e None: if len(self._lower) == len(self._upper): heappush(self._upper, -heappushpop(self._lower, -num)) else: heappush(self._lower, -heappushpop(self._upper, num)) def median(self) -\u003e float: if len(self._lower) == len(self._upper): return (self._upper[0] - self._lower[0]) / 2 return self._upper[0]   ","description":"","tags":["Heap"],"title":"Find Median From Data Stream","uri":"/algorithms/2021/07/11/find-median-from-data-stream/"},{"categories":["Algorithms","LeetCode"],"content":"Time Based Key-Value Store, LC981 Design a time-based key-value data structure that can store multiple values for the same key at different time stamps and retrieve the key’s value at a certain timestamp.\nImplement the TimeMap class:\n TimeMap() Initializes the object of the data structure. void set(String key, String value, int timestamp) Stores the key key with the value value at the given time timestamp. String get(String key, String value) Returns a value such that set was called previously, with timestamp_prev \u003c= timestamp. If there are multiple such values, it returns the value associated with the largest timestamp_prev. If there are no values, it returns \"\".  Constraints  1 \u003c= key.length, value.length \u003c= 100 key and value consist of lowercase English letters and digits. 1 \u003c= timestamp \u003c= 10**7 All the timestamps timestamp of set are strictly increasing. At most 2 * 10**5 calls will be made to set and get.  Solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  class TimeMap: def __init__(self): self._d = {} def set(self, key: str, value: str, timestamp: int) -\u003e None: if key not in self._d: self._d[key] = [(0, \"\"), (timestamp, value)] else: self._d[key].append((timestamp, value)) def get(self, key: str, timestamp: int) -\u003e str: if key not in self._d: return \"\" temp = self._d[key] i = bisect_left(temp, (timestamp, \"~\")) return temp[i-1][1]   ","description":"","tags":["Map","Binary Search"],"title":"Time Based Key Value Store","uri":"/algorithms/2021/07/10/time-based-key-value-store/"},{"categories":["Algorithms","LeetCode"],"content":"Best Sightseeing Pair, LC1014 You are given an integer array values where values[i] represents the value of the ith sightseeing spot. Two sightseeing spots i and j . have a distance j-i between them.\nThe score of a pair (i \u003c j) of sightseeing spots is values[i] + values[j] + i - j: the sum of the values of the sightseeing spots, minus the distance between them\nReturn the maximum score of a pair of sightseeing spots.\nConstraints  2 \u003c= values.length \u003c= 5 * 10**4 1 \u003c= values[i] \u003c= 1000  Examples   Input: values = [8,1,5,2,6]; Output: 11 Input: values = [1,2]; Output: 2   Solution 1 2 3 4 5 6  def best_sightseeing_pair(values: List[int]) -\u003e int: result = upper = 0 for i, v in enumerate(values): result = max(result, upper + v - i) upper = max(upper, v + i) return result   Best Time to Buy and Sell stock, LC121 You are given an array prices where pairs[i] is the price of a given stock on the ith day.\nYou want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.\nReturn the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.\nConstraints  1 \u003c= prices.length \u003c= 10**5 0 \u003c= prices[i] \u003c= 10**4  Examples   Input: prices = [7,1,5,3,6,4]; Output: 5 Input: prices = [7,6,4,3,1]; Output: 0   Solution 1 2 3 4 5 6  def max_profit(prices: List[int]) -\u003e int: result, lower = 0, prices[0] for x in prices: result = max(result, x-lower) lower = min(lower, x) return result   Best Time to Buy an Sell Stock II, LC122 You are given an array prices where prices[i] is the price of a given stock on the ith day.\nFind the maximum profit you can achieve. You may complete as many transactions as you like (i.e. buy one and sell one share of the stock multiple times)\nNote: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again)\nConstraints  1 \u003c= prices.length \u003c= 3 * 10**5 0 \u003c= prices[i] \u003c= 10**4  Examples   Input: prices = [7,1,5,3,6,4]; Output: 7 Input: prices = [7,6,4,3,1]; Output: 0   Solution 1 2 3 4 5 6  def max_profit(prices: List[int]) -\u003e int: result = 0 for i in range(1, len(prices)): if prices[i] \u003e prices[i-1]: result += prices[i] - prices[i-1] return result   ","description":"","tags":["DP","Greedy"],"title":"Best Sightseeing Pair","uri":"/algorithms/2021/07/10/best-sightseeing-pair/"},{"categories":["Algorithms","LeetCode"],"content":"Decode Ways, LC91 A message containing letters A-Z can be encoded into numbers using the following mapping:\n A -\u003e 1 B -\u003e 2 ... Z -\u003e 26  To decode an encode message, all the digits must be grouped then mapped back into letters using the reverse of the mapping above (there may be multiple ways). For example, \"11106\" can be mapped into:\n \"AAJF\" with the grouping (1 1 10 6) \"KJF\" with the grouping (11 10 6)  Note that the grouping (1 11 06) is invalid because \"06\" cannot be mapped into 'F' since \"6\" is different from \"06\".\nGiven a string s containing only digits, return the number of ways to decode it.\nThe answer is guaranteed to fit in a 32-bit integer.\nConstraints  1 \u003c= s.length \u003c= 100 s contains only digits and may contain leading zero(s).  Examples   Input: s = “226”; Output: 3 Input: s = “06”; Output: 0 Input: s = “12”; Output: 2   Solution 1 2 3 4 5 6 7 8 9  def num_decodings(s: str) -\u003e int: f = [1] + [0] * len(s) f[1] = int(s[0] != '0') for i in range(1, len(s)): f[i+1] = f[i] if s[i] != '0' else 0 if '10' \u003c= s[i-1:i+1] \u003c= '26': f[i+1] += f[i-1] return f[-1]   1 2 3 4 5 6 7 8 9  def num_decodings(s: str) -\u003e int: prev, it = 1, int(s[0] != '0') for i in range(1, len(s)): temp = it it = it if s[i] != '0' else 0 if '10' \u003c= s[i-1:i+1] \u003c= '26': it += prev prev = temp return it   Decode Ways II, LC639 Following up:\nIn addition to the mapping above, an encoded message may contain the '*' character, which can represent any digit from '1' to '9' ('0' is excluded).\nSince the answer may be very large, return it modulo 10**9 + 7.\nConstraints  1 \u003c= s.length \u003c 10**5 s[i] is a digit or '*'  Examples   Input: s = “*\"; Output: 9 Input: s = “1*\"; Output: 18 Input: s = “2*\"; Output: 15   Solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  def num_decodings(s: str) -\u003e int: MOD = 10**9 + 7 prev, it = 1, 9 if s[0] == '*' else int(s[0] != '0') for i in range(1, len(s)): temp = it if s[i] == '*': it *= 9 if s[i-1] == '1': it += prev * 9 elif s[i-1] == '2': it += prev * 6 elif s[i-1] == '*': it += prev * 15 else: it = it if s[i] != '0' else 0 if s[i-1] == '1': it += prev elif s[i-1] == '2' and s[i] \u003c= '6': it += prev elif s[i-1] == '*': it += prev * (2 if s[i] \u003c= '6' else 1) prev, it = temp, it % MOD return it   ","description":"","tags":["DP"],"title":"Decode Ways","uri":"/algorithms/2021/07/10/decode-ways/"},{"categories":["Algorithms","LeetCode"],"content":"Problem, LC169 Given an array nums of size n, return the majority element, otherwise, return -1.\nThe majority element is the element that appears more the n//2 times\nConstraints  1 \u003c= nums.length \u003c= 5 * 10**4 -2**31 \u003c= nums[i] \u003c= 2**31 + 1  Examples   Input: nums = [3,2,3]; Output: 3 Input: nums = [1,2,3]; Output: -1   Solution 1 2 3 4 5 6  def majority_element(nums: List[int]) -\u003e int: n, count = len(nums), Counter(nums) for k, v in count.items(): if v * 2 \u003e n: return k return -1   1 2 3 4 5 6 7  def majority_element(nums: List[int]) -\u003e int: temp = count = 0 for x in nums: if not count: temp = x count += 1 if temp == x else -1 return -1 if nums.count(temp) * 2 \u003c= n else temp   ","description":"","tags":["Map"],"title":"Majority Element","uri":"/algorithms/2021/07/09/majority-element/"},{"categories":["Algorithms","LeetCode"],"content":"Problem, LC Given an integer array nums, return the length of the longest strictly increasing subsequence.\nA subsequence is a sequence that can be derived from an array by deleting some or no elements without changing the order of the remaining elements, For example, [3,6.2.7] is a subsequence of the array [0,3,1,6,2,2,7].\nConstraints  1 \u003c= nums.length \u003c= 2500 -10**4 \u003c= nums[i] \u003c= 10**4  Examples   Input: nums = [10,9,2,5,3,7,101,18]; Output: 4 Input: nums = [0,1,0,3,2,3]; Output: 4   Solution 1 2 3 4 5 6 7 8 9  def longest_increasing_subsequence(nums: List[int]) -\u003e int: lis = [] for x in nums: i = bisect_left(lis, x) if i == len(lis): lis.append(x) else: lis[i] = x return len(lis)   ","description":"","tags":["Binary Search","DP"],"title":"Longest Increasing Subsequence","uri":"/algorithms/2021/07/09/longest-increasing-subsequence/"},{"categories":["Algorithms","LeetCode"],"content":"Maximum Product Subarray, LC152 Given an integer array nums, find a contiguous non-empty subarray within the array that has the largest product, and return the product.\nIt is guaranteed that the answer will fit in a 32-bit integer.\nA subarray is a contiguous subsequence of the array.\nConstraints  1 \u003c= nums.length \u003c= 2 * 10**4 -10 \u003c= nums[i] \u003c= 10 The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.  Examples   Input: nums = [2,3,-2,4]; Output: 6 Input: nums = [-2,0,-1]; Output: 0 Input: nums = [-1]; Output: -1   Solution 1 2 3 4 5 6 7  def max_product(nums: List[int]) -\u003e int: lower = upper = result = nums[0] for i in range(1, len(nums)): s, t = lower * nums[i], upper * nums[i] lower, upper = min(s, t, nums[i]), max(s, t, nums[i]) result = max(result, upper) return result   [Maximum Length of Subarray With Positive Product] Given an array of integers nums, find the maximum length of a subarray where the product of all its elements is positive.\nA subarray of an array is a consecutive sequence of zero or more values taken out of that array.\nReturn the maximum length of a subarray with positive product.\nConstraints  1 \u003c= nums.length \u003c= 10**5 -10**9 \u003c= nums[i] \u003c= 10**9  Examples   Input: nums = [1,2,3]; Output: 3 Input: nums = [-1,-2,-3]; Output: 2 Input: nums = [1,0,2,3]; Output: 2 Input: nums = [-1,0,-2]; Output: 0   Solution 1 2 3 4 5 6 7 8 9 10 11  def max_length_with_positive_product(nums: List[int]) -\u003e int: positive = negative = result = 0 for x in nums: if x == 0: positive = negative = 0 elif x \u003e 0: positive, negative = position + 1, negative + 1 if negative else 0 else: positive, negative = negative + 1 if negative else 0, positive + 1 result = max(result, positive) return result   ","description":"","tags":["DP"],"title":"Maximum Product Subarray","uri":"/algorithms/2021/07/09/maximum-product-subarray/"},{"categories":["Algorithms","LeetCode"],"content":"Maximum Length of Repeated Subarray, LC718 Given two integer arrays nums1 and nums2, return the maximum length of a subarray that appears in both arrays\nConstraints  1 \u003c= nums1.length, nums2.length \u003c= 1000 0 \u003c= nums1[i], nums2[i] \u003c= 100  Examples   Input: nums1 = [1,2,3,2,1], nums2 = [3,2,1,4,7]; Output: 3 Input: nums1 = [0,0,0,0,0], nums2 = [0,0,0,0,0]; Output: 5   Solution 1 2 3 4 5 6 7 8 9 10  def max_length_repeated_subarray(nums1: List[int], nums2: List[int]) -\u003e int: m, n = len(nums1) + 1, len(nums2) + 1 f = [[0] * n for _ in range(m)] result = 0 for i in range(1, m): for j in range(1, n): if nums1[i-1] == nums2[j-1]: f[i][j] = 1 + f[i-1][j-1] result = max(result, f[i][j]) return result   ","description":"","tags":["DP"],"title":"Maximum Length of Repeated Subarray","uri":"/algorithms/2021/07/08/maximum-length-of-repeated-subarray/"},{"categories":["Algorithms","LeetCode"],"content":"Binary Subarrays with Sum, LC930 Given a binary array nums and an integer goal, return the number of non-empty subarrays with a sum goal.\nA subarray is a contiguous part of the array.\nConstraints  1 \u003c= nums.length \u003c= 3 * 10**4 nums[i] is either 0 or 1 0 \u003c= goal \u003c= nums.length  Examples   Input: nums = [1,0,1,0,1], goal = 2; Output: 4 Input: nums = [0,0,0,0,0], goal = 0; Output: 15   Solution 1 2 3 4 5 6 7 8  def num_subarray_with_sum(nums: List[int], goal: int) -\u003e int: count = Counter([0]) result = prefix = 0 for x in nums: prefix += x result += count[prefix-goal] count[prefix] += 1 return result   1 2 3 4 5 6 7 8  def num_subarray_with_sum(nums: List[int], goal: int) -\u003e int: count = [1] + [0] * len(nums) result = prefix = 0 for x in nums: prefix += x result += count[prefix-goal] count[prefix] += 1 return result   ","description":"","tags":["Map","Iterate"],"title":"Binary Subarrays with Sum","uri":"/algorithms/2021/07/08/binary-subarrays-with-sum/"},{"categories":["Algorithms","LeetCode"],"content":"Maximum Subarray, LC53 Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.\nConstraints:  1 \u003c= nums.length \u003c= 3 * 10**4 -10**5 \u003c= nums[i] \u003c= 10**5  Example:   Input: nums = [-2,1,-3,4,-1,2,1,-5,4]; Output: 6 Input: nums = [1]; Output: 1 Input: nums = [5,4,-1,7,8]; Output: 23   Solution 1 2 3 4 5 6  def max_subarray(nums: List[int]) -\u003e int: temp = result = -float('inf') for x in nums: temp = max(x, temp+x) result = max(result, temp) return result   Maximum Sum Circular Subarray, LC918 Given a circular integer array nums of length n, return the maximum possible sum of a non-empty subarray of nums.\nA circular array means the end of the array connects to the beginning of the array.\nConstraints  1 \u003c= nums.length \u003c= 3 * 10**4 -3 * 10**4 \u003c= nums[i] \u003c= 3 * 10**4  Examples   Input: nums = [5,-3,5]; Output: 10 Input: nums = [3,-1,2,-1]; Output: 4 Input: nums = [1,2,3]; Output: 6 Input: nums = [-1,-2,-3]; Output: -1   Solution 1 2 3 4 5 6 7 8 9 10 11  def max_subarray_sum_circular(nums: List[int]) -\u003e int: total = 0 upper = i = -float('inf') lower = j = float('inf') for x in nums: total += x i = max(x, x + i) upper = max(upper, i) j = max(x, x + j) lower = max(lower, j) return upper if upper \u003c= 0 else max(upper, total - lower)   ","description":"","tags":["DP"],"title":"Maximum Subarray","uri":"/algorithms/2021/07/08/maximum-subarray/"},{"categories":["Algorithms","LeetCode"],"content":"Kth Smallest Element in a sorted matrix, LC378 Given an n x n matrix where each of the rows and columns are sorted in ascending order, return the kth smallest element in the matrix.\nNote that it is the kth smallest element in the sorted order, not the kth distinct element.\nConstraints  1 \u003c= matrix.length, matrix[i].length \u003c= 300 -10**9 \u003c= matrix[i][j] \u003c= 10**9 All the rows and columns of matrix are guaranteed to be sorted in non-decreasing order. 1 \u003c= k \u003c= matrix.length * matrix[i].length  Examples   Input: matrix = [[1,5,9],[10,11,13],[12,13,15]], k = 8; Output: 13   Solution 1 2  def kth_smallest(matrix: List[List[int]], k: int) -\u003e int: return list(heapq.merge(*matrix))[k-1]   ","description":"","tags":["Sort"],"title":"Kth Smallest Element in a Sorted Matrix","uri":"/algorithms/2021/07/07/kth-smallest-element-in-a-sorted-matrix/"},{"categories":["Algorithms","LeetCode"],"content":"Count Good Meals, LC1711 A good meal is a meal that contains exactly two different food items with a sum of deliciousness equal to a power of two.\nYou can pick any two different foods to make a good meal.\nGiven an array of integers deliciousness where deliciousness[i] is the deliciousness of the ith item of food, return the number of different good meals you can make from this list modulo 10**9+7.\nConstraints:  1 \u003c= deliciousness.length \u003c= 10**5 0 \u003c= deliciousness[i] \u003c= 2 ** 20  Example:   Input: deliciousness = [1,3,5,7,9]; Output: 4 Input: deliciousness = [1,1,1,3,3,3,7]; Output: 15   Solution 1 2 3 4 5 6 7  def count_pairs(deliciousness: List[in]) -\u003e int: twos = [1 \u003c\u003c i for i in range(31)] MOD, result, count = 10**9 + 7, 0, Counter() for x in deliciousness: result += sum(count[i-x] for i in twos) % MOD count[x] += 1 return result % MOD   ","description":"","tags":["Map"],"title":"Count Good Meals","uri":"/algorithms/2021/07/07/count-good-meals/"},{"categories":["Algorithms","LeetCode"],"content":"Jump Game, LC55 Given an array of non-negative integers nums, you are initially positioned at the first index of the array.\nEach element in the array represents your maximum jump length at that position.\nDetermine if you are able to reach the last index.\nConstraints:  1 \u003c= nums \u003c= 10**4 0 \u003c= nums[i] \u003c= 10**5\n Example:   Input: [2,3,1,1,4]; Output: true Input: [3,2,1,0,4]; Output: false   Solution 1 2 3 4 5 6 7 8  def can_jump(nums: List[int]) -\u003e bool: far = 0 for i, x in enumerate(nums): if far \u003e= i: far = max(far, x + i) if far \u003e= len(nums) - 1: return True return False   Jump Game II, LC45 Given an array of non-negative integers nums, you are initially positioned at the first index of the array.\nEach element in the array represents your maximum jump length at that position.\nYour goal is to reach the last index in the minimum number of jumps.\nYou can assume that you can always reach the last index.\nConstraints:  1 \u003c= nums \u003c= 10**4 0 \u003c= nums[i] \u003c= 10**5\n Example:   Input: [2,3,1,1,4]; Output: 2 Input: [2,3,0,1,4]; Output: 2   Solution 1 2 3 4 5 6 7 8 9  def jump(nums: List[int]) -\u003e int: nums.pop() far = step = end = 0 for i, x in enumerate(nums): far = max(far, x + i) if end == i: end = far step += 1 return step   ","description":"","tags":["DP"],"title":"Jump Game","uri":"/algorithms/2021/07/07/jump-game/"},{"categories":["Algorithms","LeetCode"],"content":"Problem, LC1338 Given an array arr. You can choose a set of integers and remove all the occurrences of these integers in the array.\nReturn the minimum size of the set so that at least half of the integers of the array are removed.\nConstraints:  1 \u003c= arr.length \u003c= 10**5 arr.length is even 1 \u003c= arr[i] \u003c= 10**5  Example:   Input: arr = [1,2,3,4,5,6,7,8,9,10]; Output: 5 Input: arr = [3,3,3,3,5,5,5,2,2,7]; Output: 2   Solution 1 2 3 4 5 6  def min_set_size(arr: List[int]) -\u003e int: n = len(arr) // 2 for i, (_, c) in enumerate(Counter(arr).most_common()): n -= c if n \u003c= 0: return i+1   ","description":"","tags":["Map"],"title":"Reduce Array Size to the Half","uri":"/algorithms/2021/07/06/reduce-array-size-to-the-half/"},{"categories":["Algorithms","LeetCode"],"content":"Problem, LC198 You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into ton the same night.\nGiven an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.\nConstraints:  1 \u003c= nums.length \u003c= 100 0 \u003c= nums[i] \u003c= 400  Example:   Input: nums = [1,2,3,1]; Output: 4 Input: nums = [2,7,9,3,1]; Output: 12   Solution 1 2 3 4 5  def rob(nums: List[int]) -\u003e int: skipped = best = 0 for x in nums: skipped, best = best, max(skipped+x, best) return best   Problem 2, LC213 You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have a security system connected, and it will automatically contact the police if two adjacent houses were broken into on the same night.\nGiven an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.\nConstraints:  1 \u003c= nums.length \u003c= 100 0 \u003c= nums[i] \u003c= 1000  Example:   Input: nums = [2,3,2]; Output: 3 Input: nums = [1,2,3,2]; Output: 4   Solution: 1 2 3 4 5 6 7 8 9 10 11  def rob(nums: List[int]) -\u003e int: if len(nums) \u003c= 2: return max(nums) skipped = best1 = 0 for x in nums[1:]: skipped, best1 = best1, max(skipped+x, best1) skipped = best2 = 0 for x in nums[:-1]: skipped, best2 = best2, max(skipped+x, best2) return max(best1, best2)   Problem 3, LC740 You are given an integer array nums. You want to maximize the number of points you get by performing the following operation any number of times:\n Pick any nums[i] and delete it to earn nums[i] points. Afterwards, you must delete every element equal to nums[i]-1 and every element equal to nums[i]+1  Return the maximum number of points you can earn by applying the above operation some number of times.\nConstraints:  1 \u003c= nums.length \u003c= 2 * 10**4 1 \u003c= nums[i] \u003c= 10**4  Example:   Input: nums = [2,2,3,3,3,4]; Output: 9 Input: nums = [3,4,2]; Output: 6   Solution 1 2 3 4 5 6 7  def delete_and_earn(nums: List[int]) -\u003e int: count = Counter(nums) start, end = min(count.keys()), max(count.keys()) skipped = best = 0 for x in range(start, end+1): skipped, best = best, max(skipped + count[x]*x, best) return best   ","description":"","tags":["DP"],"title":"House Robber","uri":"/algorithms/2021/07/06/house-robber/"},{"categories":["Algorithms","LeetCode"],"content":"Problem, LC1418 Given the array orders, which represents the orders that customers have done in a restaurant. More specifically orders[i] = [customerName, tableNumber, foodItem] where customerName is the name of the customer, tableNumber is the table customer sit at, and foodItem is the item customer orders.\nReturn the restaurant’s “display table”. The “display table” is a table whose row entries denote how many of each food item each table ordered. The first column is the table number and the remaining columns correspond to each food item in alphabetical order. The first row should be a header whose first column is “Table”, followed by the names of the food items. Note that the customer names are not part of the table. Additionally, the rows should be sorted in numerically increasing order.\nConstraints:  1 \u003c= orders.length \u003c= 5 * 10**4 order[i].length == 3 1 \u003c= customerName.length, foodItem.length \u003c= 20 customerName and foodItem consist of lowercase and uppercase English letters and the space character. tableNumber is a valid integer between 1 and 500  Example:   Input: orders = [[“James”,“12”,“Fried Chicken”],[“Ratesh”,“12”,“Fried Chicken”],[“Amadeus”,“12”,“Fried Chicken”],[“Adam”,“1”,“Canadian Waffles”],[“Brianna”,“1”,“Canadian Waffles”]]; Output: [[“Table”,“Canadian Waffles”,“Fried Chicken”],[“1”,“2”,“0”],[“12”,“0”,“3”]]   Solution 1 2 3 4 5 6 7 8 9 10 11 12  def display_table(orders: List[List[str]]) -\u003e List[List[str]]: tables = defaultdict(Counter) foods = set() for _, table, food in orders: foods.add(food) tables[table][food] += 1 foods = sorted(foods) result = [[\"Table\"] + foods] for table, count in sorted(tables.items(), key=lambda x: int(x[0])): result.append([table] + [str(count[f]) for f in foods]) return result   ","description":"","tags":["Set","Map","Sort"],"title":"Display Table of Food Orders in a Restaurant","uri":"/algorithms/2021/07/06/display-table-of-food-orders-in-a-restaurant/"},{"categories":["Algorithms","LeetCode"],"content":"Problem, LC726 Given a chemical formula (given as a string), return the count of each atom.\nThe atomic element always starts with an uppercase character, then zero or more lowercase letters, representing the name.\nOne or more digits representing that element’s count may follow if the count is greater than 1. If the count is 1 no digits will follow. For example, H20 and H2O2 are possible, but H1O2 is impossible.\nTwo formulas concatenated together to produce another formula. For example, H2O2He3Mg4 is also a formula.\nA formula placed in parentheses, and a count (optionally added) is also a formula. For example, (H2O2) and (H2O3) are formula.\nGiven a formula, return the count of all elements as a string in the following form: the first name (in sorted order), followed by its count (if that count is more than 1), followed by the second name (in sorted order), followed by its count (if that count is more than 1), and so on.\nConstraints:  1 \u003c= formula.length \u003c= 1000 formula consists of English letters, digits, '(' and ')' formula is always valid.  Example:   Input: formula = “H2O”; Output: “H2O” Input: formula = “Mg(OH)2”; Output: “H2MgO2” Input: formula = “K4(ON(SO3)2)2”; Output: “K4N2O14S4”   Solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  def count_of_atom(formula: str) -\u003e str: count = Counter() factors = [1] factor = atom = '' for c in formula[::-1]: if c == ')': factors.append(factors[-1] * (int(factor) if factor else 1)) factor = '' elif c == '(': factors.pop() elif '0' \u003c= c \u003c= '9': factor = c + factor else: atom = c + atom if 'A' \u003c= c \u003c= 'Z': count[atom] += (int(factor) if factor else 1) * factors[-1] factor = atom = '' return ''.join(f\"{k}{v if v \u003e 1 else ''}\" for k, v in sorted(count.items()))   ","description":"","tags":["Math","Map"],"title":"Number of Atoms","uri":"/algorithms/2021/07/05/number-of-atoms/"},{"categories":["Algorithms","LeetCode"],"content":"[Problem, LC] You are given an m x n matrix mat and two integers r and c representing the row number and column number of the wanted reshaped matrix.\nThe reshaped matrix should be filled with all the elements of the original matrix in the same row-traversing order as they were.\nIf the reshape operation with given parameters is possible and legal, output the new reshaped matrix; Otherwise, output the original matrix.\nConstraints:  1 \u003c= mat.length, mat[i].length \u003c= 100 -1000 \u003c= mat[i][j] \u003c= 1000 1 \u003c= r, c \u003c= 300  Example:   Input: mat = [[1,2], [3,4]], r = 2, c = 4; Output: [[1,2], [3,4]] Input: mat = [[1,2], [3,4]], r = 1, c = 4; Output: [[1,2,3,4]]   Solution 1 2 3 4 5 6 7 8 9  def reshape_matrix(mat: List[List[int]], r: int, c: int) -\u003e List[List[int]]: if r * c != len(mat) * len(mat[0]): return mat result = [[0] * c for _ in range(r)] for k, x in enumerate(chain(*mat)): i, j = divmod(k, c) result[i][j] = x return result   ","description":"","tags":["Iterate"],"title":"Reshape the Matrix","uri":"/algorithms/2021/07/05/reshape-the-matrix/"},{"categories":["Algorithms","LeetCode"],"content":"Problem, LC70 You are climbing a staircase. It takes n steps to reach the top.\nEach time you can either 1 or 2 steps. In how many distinct ways can you climb to the top?\nConstraints:  1 \u003c= n \u003c= 45  Example:   Input: n = 2; Output: 2 Input: n = 3; Output: 3   Solution 1 2 3 4 5 6  def climb_stairs(n: int) -\u003e int: \"\"\"f[i] = f[i-1] + f[i-2]\"\"\" prev, it = 1, 2 for _ in range(1, n): prev, it = it, prev+it return prev   Problem2, LC726 You are given an integer array cost where cost[i] is the cost of ith step on a staircase. Once you pay the cost, you can either climb one or two steps.\nYou can either start from the step with index 0, or the step with index 1.\nReturn the minimum cost to reach the top of the floor.\nConstraints:  2 \u003c= cost.length \u003c= 1000 0 \u003c= cost[i] \u003c= 999  Example:   Input: [1,100,1,1,1,100,1,1,100,1]; Output: 6 Input: [10,15,20]; Output: 15   Solution 1 2 3 4 5 6  def min_cost_climb_stairs(cost: List[int]) -\u003e int: \"\"\"f[i] = cost[i] + min(f[i-1], f[i-2])\"\"\" cost.append(0) for i in range(2, len(cost)): cost[i] += min(cost[i-1], cost[i-2]) return cost[-1]   1 2 3 4 5  def min_cost_climb_stairs(cost: List[int]) -\u003e int: a, b = 0, 0 for i in range(2, len(cost)): a, b = b, min(a + cost[i-2], b + cost[i-1]) return b   ","description":"","tags":["DP"],"title":"Climbing Stairs","uri":"/algorithms/2021/07/05/climbing-stairs/"},{"categories":["Algorithms","LeetCode"],"content":"Problem LC509 The Fibonacci numbers, commonly denotes F(n) form a sequence, called the Fibonacci sequence, such that each number is the sum of the two preceding ones, starting from 0 and 1. That is,\nF(0) = 0, F(1) = 1, F(n) = F(n-1) + F(n-2), for n \u003e 1 Given n, calculate F(n).\nConstraints:  0 \u003c= n \u003c= 30  Example:   Input: n = 2; Output: 1 Input: n = 3; Output: 2   Solution: 1 2 3 4 5  def fib(n: int) -\u003e int: a, b = 0, 1 for _ in range(n): a, b = b, a+b return a   Problem, LC1137 The Tribonacci sequence T(n) is defined as follows:\nT(0) = 0, T(1) = 1, T(2) = 2, and T(n) = T(n-1) + T(n-2) + T(n-3) for n \u003e 2 Given n, return the value of T(n)\nConstraints:  0 \u003c= n \u003c= 37 The answer is guaranteed to fit within a 32-bit integer.  Example:   Input: n = 4; Output: 4 Input: n = 25; Output: 1389537   Solution 1 2 3 4 5  def tribonacci(n: int) -\u003e int: a, b, c = 0, 1, 1 for _ in range(n): a, b, = b, c, a+b+c return a   ","description":"","tags":["DP","Fibonacci"],"title":"Fibonacci Number","uri":"/algorithms/2021/07/04/fibonacci-number/"},{"categories":["Algorithms","LeetCode"],"content":"Problem, LC1220 Given an integer n, your task is to count how many strings of length n can be formed under the following rules:\n Each character is a lower case vowel \"aeiou\" Each vowel 'a' may only be followed by an 'e' Each vowel 'e' may only be followed by an 'a' or an 'i' Each vowel 'i' may NOT be followed by another 'i' Each vowel 'o' may only be followed by an 'i' or a 'u' Each vowel 'u' may only be followed by an 'a'.  Since the answer may be too large, return it modulo 10**9+7.\nConstraints:  1 \u003c= n \u003c= 2 * 10**4  Example:   Input: n = 1; Output: 5 Input: n = 2; Output: 10   Solution 1 2 3 4 5 6  def count_vowel_permutation(n: int) -\u003e int: MOD = 10**9 + 7 a = e = i = o = u = 1 for _ in range(1, n): a, e, i, o, u = e, (a+i)%MOD, (a+e+o+u)%MOD, (i+u)%MOD, a return (a+e+i+o+u) % MOD   ","description":"","tags":["DP"],"title":"Count Vowels Permutation","uri":"/algorithms/2021/07/04/count-vowels-permutation/"},{"categories":["Algorithms","LeetCode"],"content":"Problem, LC327 Given an integer array nums and two integers lower and upper, return the number of range sums that lie in [lower, upper] inclusive.\nRange sum S(i, j) is defined as the sum of the elements in nums between indices i and j inclusive, where i \u003c= j.\nConstraints:  1 \u003c= nums.length \u003c= 10**5 -2**31 \u003c= nums[i] \u003c= 2*31 - 1 -10**5 \u003c= lower \u003c= upper \u003c= 10**5 The answer is guaranteed to fit in a 32-bit integer.  Example:   Input: nums = [-2, 5, -1], lower = -2, upper = 2; Output: 3 Input: nums = [0], lower = 0, upper = 0; Output: 1   Solution 1 2 3 4 5 6 7 8 9  def count_range_sum(nums: List[int], lower: int, upper: int) -\u003e int: \"\"\"Fails to Constraints 1: 10**5 O(n2)\"\"\" prefix = [0] + list(accumulate(nums)) n = len(prefix) return sum( lower \u003c= prefix[j]-prefix[i] \u003c= upper for i in range(n-1) for j in range(i+1, n) )   1 2 3 4  def count_range_sum(nums: List[int], lower: int, upper: int) -\u003e int: sorted_prefix = [0] + list(accumulate(nums))   ","description":"","tags":[],"title":"Count of Range Sum","uri":"/algorithms/2021/07/03/count-of-range-sum/"},{"categories":["Algorithms","LeetCode"],"content":"Problem, LC645 You have a set of integers s, which originally contains all the numbers from 1 to n. Unfortunately, due to some error, one of the numbers in s got duplicated to another number in the set, which results in repetition of one number and loss of another number.\nYou are given an integer array nums representing the data status of this set after the error.\nFind the number that occurs twice and the number that is missing and return them in the form of an array.\nConstraints:  2 \u003c= nums.length \u003c= 10**4 1 \u003c= nums[i] \u003c= 10**4  Example:   Input: nums = [1,2,2,4]; Output: [2,3] Input: nums = [1,1]; Output: [1,2]   1 2 3  def find_error_nums(nums: List[int]) -\u003e List[int]: s = sum(set(nums)) return [sum(nums) - s, (len(nums)+1)*len(nums)//2 - s]   ","description":"","tags":["Set"],"title":"Set Mismatch","uri":"/algorithms/2021/07/04/set-mismatch/"},{"categories":["Algorithms","LeetCode"],"content":"Problem, BS630 You are given a list of positive integers coins and quantities of the same length. The value of coin i is coins[i] and you currently have quantities[i] number of them. Return the number of distinct coin sum values you can get by using non-empty group of these coins.\nConstraints:  n \u003c= 10 where n is the length of coins k \u003c= 200 where k is the sum of the quantities  Example:   Input: coins = [4,2,1], quantities = [1,2,1] Output: 9   Solution 1 2 3 4 5  def distinct_coin_sums(coins: List[int], quantities: List[int]) -\u003e int: seen = {0} for c, q in zip(coins, quantities): seen |= {x + c * (i+1) for x in seen for i in range(q)} return len(seen) - 1   1 2 3 4 5 6  def distinct_coin_sums_mask(coins: List[int], quantities: List[int]) -\u003e int: mask = 1 for c, q in zip(coins, quantities): for _ range(q): mask |= mask \u003c\u003c c return bin(mask).count('1') - 1   ","description":"","tags":["BFS","DP","Bit Mask"],"title":"Distinct Coin Sums","uri":"/algorithms/2021/07/02/distinct-coin-sums/"},{"categories":["Algorithms","LeetCode"],"content":"Problem, LC451 Given a string s, sort it in decreasing order based on the frequency of characters, and return the sorted string.\nConstraints:  1 \u003c= s.length \u003c= 5e5 s consists of English letters and digits  Example:   Input: “tree” Output: “eert”   Solution 1 2 3  def frequency_sort(s: str) -\u003e str: frequency = sorted((-v, k) for k, v in Counter(s).items()) return ''.join(k * -v for v, k in frequency)   ","description":"","tags":["String","Sort"],"title":"Sort Characters by Frequency","uri":"/algorithms/2021/07/03/sort-characters-by-frequency/"},{"categories":["Algorithms","LeetCode"],"content":"Problem, LC1833 It is a sweltering summer day, and a boy wants to buy some ice cream bars.\nAt the store, there are n ice cream bars. You are given an array costs of length n, where costs[i] is the price of the ith ice cream bar in coins. The boy initially has coins coins to spend, and he wants to buy as many ice cream bars as possible. Return the maximum number of ice cream bars the boy can buy with coins coins.\nNote: The boy can buy the ice cream bars in any order.\nSolution 1 2 3 4 5 6 7 8 9  def max_ice_cream(costs: List[int], coins: int) -\u003e int: costs.sort() result = 0 for c in costs: coins -= c if coins \u003c 0: return result result += 1 return result   1 2 3 4 5 6 7 8 9 10 11  from heapq import heapify, heappop def max_ice_cream(costs: List[int], coins: int) -\u003e int: heapify(costs) result = 0 while costs: coins -= heappop(costs) if coins \u003c 0: return result result += 1 return result   ","description":"","tags":["Greedy","Sort","Heap"],"title":"Maximum Ice Cream Bars","uri":"/algorithms/2021/07/02/maximum-ice-cream-bars/"},{"categories":["Algorithms","LeetCode"],"content":"Gray Code, LC89 An n-bit gray code sequence is a sequence of $2^n$ integers where:\n Every integer is in the inclusive range $[0, 2^n-1]$ The first integer is 0. An integer appears no more than once in the sequence. The binary representation of every pair of adjacent integers differs by exactly one bit, and The binary representation of the first and last integers differs by exactly one bit.  Given an integer n, return any valid n-bit gray code sequence.\nSolution 1 2  def gray_code(n: int) -\u003e List[int]: return [i^(i\u003e\u003e1) for i in range(1\u003c\u003cn)]   1 2 3 4 5  def gray_code(n: int) -\u003e List[int]: if n == 1: return [0, 1] result, base = gray_code(n-1), 1\u003c\u003c(n-1) return result + [i + base for i in result[::-1]]   1 2 3 4 5 6  def gray_code(n: int) -\u003e List[int]: result = [0, 1] for i in range(1, n): base = 1 \u003c\u003c i result += [i + base for i in result[::-1]] return result   ","description":"","tags":[],"title":"Gray Code","uri":"/algorithms/2021/07/01/gray-code/"},{"categories":["Algorithms","LeetCode"],"content":"Problem 小朋友 A 在和 ta 的小伙伴们玩传信息游戏，游戏规则如下：\n有 n 名玩家，所有玩家编号分别为 0 ～ n-1，其中小朋友 A 的编号为 0 每个玩家都有固定的若干个可传信息的其他玩家（也可能没有）。传信息的关系是单向的（比如 A 可以向 B 传信息，但 B 不能向 A 传信息）。 每轮信息必须需要传递给另一个人，且信息可重复经过同一个人 给定总玩家数 n，以及按 [玩家编号,对应可传递玩家编号] 关系组成的二维数组 relation。返回信息从小 A (编号 0 ) 经过 k 轮传递到编号为 n-1 的小伙伴处的方案数；若不能到达，返回 0。\n 来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/chuan-di-xin-xi\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n Solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14  def num_ways(relation: List[List[int]], n: int k: int) -\u003e int: r = defaultdict(set) for a, b in relation: r[a].add(b) seen = Counter([0]) while k: temp = Counter() for station, t in seen.items: for x in r[station]: temp[x] += t seen = temp k -= 1 return seen[n-1]   1 2 3 4 5 6 7 8 9 10 11 12  def num_ways_dfs(relation: List[List[int]], n: int, k: int) -\u003e int: r = defaultdict(set) for a, b in relation: r[a].add(b) @lru_cache(None) def dfs(i, j): # i for k, j for n if i == 0: return j == n-1 return sum(dfs(i-1, x) for x in r[j]) return dfs(k, 0)   1 2 3 4 5 6 7 8 9 10 11 12  def num_ways_dp(relation: List[List[int]], n: int, k: int) -\u003e int: r = defaultdict(set) for a, b, in relation: r[a].add(b) f = [[0] * n for _ in range(k+1)] f[0][0] = 1 for i in range(1, k+1): for j in range(n): for x in r[j]: f[i][x] += f[i-1][j] return f[-1][-1]   ","description":"","tags":["BFS","DFS","DP"],"title":"Transfer Information","uri":"/algorithms/2021/07/01/transfer-information/"},{"categories":["Algorithms","LeetCode"],"content":"Problem Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.\nDesign an algorithm to serialize and deserialize a binary tree.\nIntuition Solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  class Codec: def serialize(self, root: 'TreeNode') -\u003e str: if not root: return '' result = [] level = [root] while level and any(node for node in level): result += [str(node.val) if node else '' for node in level] level = [kid for node in level if node for kid in (node.left, node.right)] return ','.join(result) def deserialize(self, data: str) -\u003e 'TreeNode': if not data: return None nodes = [int(item) if item else None for item in data.split(',')[::-1]] root = TreeNode(nodes.pop()) queue = Deque([root]) while queue: node = queue.popleft() if node and nodes: left = nodes.pop() if left is not None: node.left = TreeNode(left) queue.append(node.left) right = nodes.pop() if right is not None: node.right = TreeNode(right) queue.append(node.right) return root   ","description":"","tags":["Tree","BFS"],"title":"Serialize Deserialize Binary Tree","uri":"/algorithms/2021/06/30/2021-06-30-seriallize-deseriallize-binary-tree/"},{"categories":["Algorithms","LeetCode"],"content":"[Lowest Common Ancestor of a Binary Tree, LC236]Problem(https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/) Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.\nAccording to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).”\nIntuition Solution 1 2 3 4 5 6 7 8 9  def least_common_ancestor(root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -\u003e 'TreeNode': if not root or root == p or root == q: return root left = least_common_ancestor(root.left, p, q) right = least_common_ancestor(root.right, p, q) if left and right: return root return left or right   ","description":"","tags":["Tree","DFS"],"title":"Lowest Common Ancestor of a Binary Tree","uri":"/algorithms/2021/06/30/lowest-common-ancestor-of-a-binary-tree/"},{"categories":["Algorithms","LeetCode"],"content":"1 2 3 4 5 6 7 8 9  def max_units(types: List[List[int]], truck: int) -\u003e int: types.sort(key=lambda x: x[1]) result = 0 while truck and types: size, unit = types.pop() x = min(truck, size) truck -= x result += x * unit return unit   ","description":"","tags":["Greedy"],"title":"Maximum Units on a Truck","uri":"/algorithms/2021/06/14/maximum-units-on-a-truck/"},{"categories":["Algorithms"],"content":"Flip Binary Tree to match Preorder Traversal  Given the root of a binary tree with n nodes, where each node is uniquely assigned a value from 1 to n. You are also given a sequence of n values voyage, which is the desired pre-order traversal of the binary tree.\nFlip the smallest number of nodes so that the pre-order traversal of the tree matches voyaga.\nReturn a list of the values of all flipped nodes. You may return the answer in any order. If it is impossible to flip the nodes in the tree to make the pre-order traversal match voyage, return the list [-1].\n 1 2 3 4 5 6 7 8 9 10 11  def flip_match_voyage(root: TreeNode, voyage: List[int]) -\u003e List[int]: self.i = 0 self.flip = [] def dfs(node): if not node or self.i == len(voyage): return if node.val != voyage[self.i]: self.flip = [-1] return   Russian Doll Envelops  Given a 2D array of integers envelops where envelops[i] = [w_i, h_i] represents the width and the height of an envelop.\n  One envelop can fit into another if and only if both the width and height of one envelop are greater than the other envelope’s width and height.\n  Return the maximum number of envelopes you can Russian doll (i.e., put one inside the other)\n  Note: You cannot rotate an envelop.\n 1 2 3 4 5 6 7 8 9 10 11  def max_envelopes(envelopes: List[List[int]]) -\u003e int: # LIS envelopes.sort(key=lambda x: (x[0], -x[1])) dp = [] for w, h in envelopes: i = bisect_left(dp, h) if i == len(dp): dp.append(h) else: dp[i] = h return len(dp)   Stamping The Sequence ","description":"","tags":[],"title":"2021 March Week 5","uri":"/algorithms/challenge/2021-march-week-5/"},{"categories":["Algorithms"],"content":"Vowel Spellchecker  Given a wordlist, we want to implement a spellchecker that converts a query word into a correct word.\n  For a given query word, the spell checker handles two categories of spelling mistakes:\n Capitalization: If the query matches a word in the wordlist, then the query word is returned with the same case as the case in the wordlist. Vowel Errors: If after replacing the vowels 'aeiou' of the query word with any vowelindiviually, it matches a word in the wordlist, then the query word is return ted with the same case as the case in the wordlist.    In addition, the spell checker operates under the following precedence rules:\n when the query exactly matched a word in the wordlist, return it when the query matches a word up to capitalization, return the first. when the query matches a word up to vowel errors, return the first otherwise, return the empty string   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  def checker(words: List[str], queries: List[str]) -\u003e List[str]: vowels = re.compile(r'[aeiou]') def check(query): if query in s: return query lower = query.lower() c = vowels.sub('?', lower) candidates = d[c] if not candidates: return '' for word in candidates: if word.lower() == query.lower(): return word return candidates[0] s = set(words) d = defaultdict(list) for word in words: d[vowels.sub('?', word.lower())].append(word) return [check(query) for query in queries]   3Sum with Multiplicity  Given an integer array arr, and an integer target, return the number of tuples i, j, k such that i \u003c j \u003c k and arr[i] + arr[j] + arr[k] == target. As the answer can be very large, return it modulo 10**9 + 7.\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14  def three_sum(arr: List[int], target:int) -\u003e int: MOD = 10 ** 9 + 7 counter = Counter(arr) result = 0 for i, j in combinations(sorted(counter.keys()), 2): k = target - i - j if i \u003c j \u003c k: result += counter[i] * counter[j] * counter[k] for i in counter: if i * 3 == target: result += comb(counter[i], 3) else: result += comb(counter[i], 2) * counter[target - i*2] return result % MOD   Advantage Shuffle  Given two arrays nums1 and nums2 of equal size, the advantage of nums1 with respect to nums2 is the number of indices i for which nums[i] \u003e nums2[i].\n  Return any permutation of nums1 that maximizes its advantage with respect to nums2.\n 1 2 3 4 5 6 7 8  def advantage_shuffle(nums1: List[int], nums2: List[int]) -\u003e List[int]: B = sorted((x, i) for i, x in enumerate(nums2)) A = Deque(sorted(nums1)) result = [0 for _ in nums1] while B: x, i = B.pop() result[i] = A.pop() if A[-1] \u003e x else A.popleft() return result   Pacific Atlantic Water Flow  Given an m x n integer matrix heights representing the height of each unit cell in a continent. The Pacific ocean touches the continent’s left and top edges, and the Atlantic ocean touches the continent’s right and bottom edges.\n  Water can only flow in four directions: up, down, left, and right. Water flows from a cell to an adjacent one with an equal or lower height.\n  Return a list of grid coordinates where water can flow to both the Pacific and Atlantic oceans.\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  def pacific_atlantic(heights: List[List[int]) -\u003e List[List[int]]: DIR = ((-1,0), (0,1), (1,0),(0,-1)) m, n = len(heights), len(heights[0]) def flow(ocean): queue = Deque(ocean) while queue: i, j = queue.popleft() h = heights[i][j] for di, dj in DIR: x, y = i+di, j+dj if 0 \u003c= x \u003c m and 0 \u003c= y \u003c n and (x, y) not in ocean and heights[x][y] \u003e= h: ocean.add((x, y)) queue.append((x, y)) return ocean p = {(i, 0) for i in range(m)} | {(0, j) for j in range(n)} a = {(i, n-1) for i in range(m)} | {(m-1, j) for j in range(n)} return [[i, j] for i, j in flow(p) \u0026 flow(a)]   Word Subsets  Given two array words1 and words2 of words. Each is a string of lowercase letters.\n  Now, say that word b is a subset of word a if every letter in b occurs in a, including multiplicity. For example, \"wrr\" is a subset of \"warrior\", but is not a subset of \"world\".\n  Now say a word a from words1 is universal if for every b in words2, b is a subset of a.\n  Return a list of all universal words in words1. You can return the words in any order.\n 1 2 3  def word_subsets(words1: List[str], words2: List[str]) -\u003e List[str]: pattern = reduce(lambda a, x: a | Counter(x), words2, Counter()) return [word for word in words1 if not (pattern - Counter(word))]   Palindromic Substrings  Given a string s, return the number of palindromic substring in it.\n 1 2 3 4 5 6 7 8 9  def count_palindromic(s: str) -\u003e int: n = len(s) result = 0 for i in range(n): for l, r in ((i, i), (i+1)): while 0 \u003c= l and r \u003c n and s[l] == s[i]: result += 1 l, r = l-1, r+1 return result   Reconstruct Original Digits from English  Given a string s containing an out-of-order English representation of digits 0-9, return the digits in ascending order.\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  def original_digits(s: str) -\u003e str: # zero: {e:1, o:1, r:1, z:1} # one: {o:1, n:1, e:1} # two: {t:1, w:1, o:1} # three: {e:2, h:1, r:1, t:1} # four: {f:1, o:1, r:1, u:1} # five: {e:1, f:1, i:1, v:1} # six: {i:1, s:1, x:1} # seven: {e:2, n:1, s:1, v:1} # eight: {e:1, g:1, h:1, i:1, t:1} # nine: {e:1, i:1, n:2} c = Counter(s) digits = ( c['z'], # 0, [z]ero c['o'] - c['z'] - c['w'] - c['u'], # 1, [o]ne, zer[o], tw[o], f[o]ur c['w'], # 2, t[w]o c['r'] - c['u'], # th[r]ee, fou[r] c['f'] - c['u'], # [f]ive, [f]our c['x'], # 6, si[x] c['s'] - c['x'], # 7 [s]even, [s]ix c['g'], # 8, ei[g]ht c['i'] - c['x'] - c['g'] - (c['f'] - c['u']), # 9, n[i]ne, s[i]x, e[i]ght, f[i]ve ) return ''.join(str(i)*c for i, c in enumerate(digits))   ","description":"","tags":null,"title":"2021 March Week 4","uri":"/algorithms/challenge/2021-march-week-4/"},{"categories":["Algorithms"],"content":"Encode and Decode TinyURL 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  class TinyUrl: CODE_LIST = string.ascii_lowercase + string.digits NUM_OF_CODE = 5 BASE_URL = 'http://tinyurl.com' def __init__(self): self._long2short = {} self._short2long = {} def encode(long_url: str) -\u003e str: while long_url not in self._long2short: code = ''.join(random.choices(TinyUrl.CODE_LIST, k = TinyUrl.NUM_OF_CODE)) if code not in self._short2long: self._short2long[code] = long_url self._long2short[long_url] = code return f'{TinyUrlBASE_URL}/{self._long2short[long_url]}' def decode(short_url: str) -\u003e str: return self._short2long[short_url[-TinyUrl.NUM_OF_CODE:]]   Best Time to Buy and Seel Stock with Transaction Fee  Given an array prices where prices[i] is the price of a given stock on the i-th day, and an integer fee representing a transaction fee.\n  Find the maximum profit you can achieve. You may complete as many transactions as you like, but you need to pay the transaction fee for each transaction. You must sell the stock before you buy agin.\n 1 2 3 4 5 6  def max_profit(prices: List[int], fee: int) -\u003e int: cash, hold = 0, -prices[0] for price in prices: cash = max(cash, hold + price - fee) hold = max(hold, cash - price) return cash   Generate Random Point in a Circle  Given the radius and the position of the center of a circle, implement the function randPoint which generates a uniform random point inside the circle.\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  class RandomPointInCircle: def __init__(self, radius, x_center, y_center): self._r = radius self._x = x_center self._y = y_center def rand_point(self): theta = math.pi * 2 * random.random() r = sqrt(random.random()) * self._r return [self._x + r * math.cos(theta), self._y + r * math.sin(theta)] def rand_point_square(self): while True: x, y = random.random() * 2 - 1, random.random() * 2 - 1 if x**2 + y**2 \u003c 1: return [self._x + x * self._r, self._y + y * self._r]   Wiggle Subsequence  A wiggle sequence is a sequence where the differences between successive numbers strictly alternate between positive and negative.\n  Given an integer array nums, return the length of the longest wiggle subsequence** of nums.\n 1 2 3 4 5 6 7 8  def longest_wiggle_subsequence(nums: List[int]) -\u003e int: positive = negative = 1 for i in range(1, len(nums)): if nums[i] \u003e nums[i-1]: positive = max(positive, negative + 1) elif nums[i] \u003c nums[i-1]: negative = max(negative, positive + 1) return max(positive, negative)   Keys and Rooms  There are N rooms and you start in room 0. Each room has a distinct number 0, 1, 2, ..., N-1, and each room may have some keys to access the next room.\n  Return true if and only if you can enter every room. The room 0 is open.\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  def can_visit_all_rooms(rooms: List[List[int]]) -\u003e bool: keys, seen = deque(rooms[0]), {0} | set(rooms[0]) while queue: key = keys.popleft() for k in room[key]: if k not in seen: seen.add(k) keys.append(k) return len(seen) == len(rooms) def can_visit_all_rooms(rooms: List[List[int]]) -\u003e bool: keys, seen = set(rooms[0]), {0} | set(rooms[0]) while keys: keys = {k for key in keys for k in rooms[key]} - seen seen |= keys return len(seen) == len(rooms)   Design Underground System  An underground railway system is keeping track of customer travel times between different stations. They are using this data to calculate the average time it takes to travel from one station to another.\n  Implement the UndergroundSystem class:\n void checkIn(int id, string stationName, int t)  A customer with a card id, checks in at station stationName at time t. A customer can only be checked into one place at at time   void checkOut(int id, string stationName, int t)  A customer with a card id, checks out at station stationName at time t.   double getAverageTime(string startStation, string endStation)  Returns the average time it takes to travel from startStation to endStation. Tje to,e ot takes to travel from startStation to endStation may be different from the time from endStation to startStation. There will be at least one customer that has traveled from startStation to endStation before getAverageTime is called.     1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  class UndergroundSystem: def __init__(self): self._checkin = {} self._timer = defaultdict(int) self._counter = defaultdict(int) def checkin(id: int, station: str, t: int) -\u003e None: self._checkin[id] = (station, t) def checkout(id: int, station: str, t: int) -\u003e None: start, begin = self._checkin[id] key = (start, station) self._timer[key] += t - begin self._counter[key] += 1 def get_average_time(start: str, end: str) -\u003e float: key = (start, end) return self._timer[key] / self._counter[key]   Reordered Power of 2  Given an integer n. We reorder the digits in any order such that the leading digit is not zero.\n  Return true if and only if we can do this so that the resulting number is a power of two.\n 1 2 3  def reordered_power_of_2(n: int) -\u003e bool: s = sorted(list(str(n))) return s in (sorted(list(str(1 \u003c\u003c i))) for i in range(31)   ","description":"","tags":null,"title":"2021 March Week 3","uri":"/algorithms/challenge/2021-march-week-3/"},{"categories":["Algorithms"],"content":"Remove Palindromic Subsequences  Given a string s consisting only of letters 'a' and 'b'. In a single step you can remove one palindromic subsequence from s.\n  Return the minimum number of steps to make the given string empty.\n 1 2 3 4 5  def remove_palindromic_subsequences(s: str) -\u003e int: # remove all 'a', then 'b' if not s: return 0 return 1 if s == s[::-1] else 2   Add One Row to Tree  Given the root of a binary tree and two integers val and depth, add a row of nodes with value val at the given depth depth.\n  Note that the root is at depth 1.\n 1 2 3 4 5 6 7 8 9 10 11 12 13  def add_row(root: TreeNode, val: int, depth:int) -\u003e TreeNode: if depth == 1: return TreeNode(val, left=root) level = [root] while level and depth \u003e 2: level = [kid for node in level for kid in (node.left, node.right) if kid] depth -= 1 for node in level: node.left = TreeNode(val, left=node.left) node.right = TreeNode(val, right=node.right) return root   Integer to Roman  Given an integer [1, 3999], convert it to a roman numeral.\n 1 2 3 4 5 6  def to_roman(num: int) -\u003e str: thousands = ('', 'M', 'MM', 'MMM') hundreds = ('', 'C', 'CC', 'CCC', 'CD', 'D', 'DC', 'DCC', 'DCCC', 'CM') tens = ('', 'X', 'XX', 'XXX', 'XL', 'L', 'LX', 'LXX', 'LXXX', 'XC') ones = ('', 'I', 'II', 'III', 'IV', 'V', 'VI', 'VII', 'VIII', 'IX') return thousands[num//1000] + hundreds[num//100%10] + tens[num//10%10] + ones[num%10]   Coin Change  Given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.\n  Return the fewest number of coins that you need to make up that amount. If that amount of money cannot by make up by any combination of the coins, return -1.\n  You may assume that you have an infinite number of each kind of coin.\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  def coin_change(coins: List[int], amount: int) -\u003e int: dp = [1] + [0] * amount for i in range(1, amount + 1): dp[i] = min((1+dp[i-c] for c in coins if i \u003e= c and dp[i-c]), default=0) return dp[-1]-1 def coin_change_bfs(coins: List[int], amount: int) -\u003e int: if amount == 0: return 0 queue, seen = deque([(0, 0)]), {0} while queue: value, piece = queue.popleft() for c in coins: temp = value + c if temp == amount: return piece + 1 if temp \u003c amount and temp not in seen: seen.add(temp) queue.append((temp, piece+1)) return -1   Check If a String Contains All Binary Codes of Size K  Given a binary string s and an integer k.\n  Return true if every binary code of length k is a substring of s. Otherwise, return false.\n 1 2 3 4 5  def has_all_codes(s: str, k: int) -\u003e bool: return all(bin(i)[2:].zfill(k) in s for i in range(1 \u003c\u003c k)) def has_all_codes(s: str, k:int) -\u003e bool: return len({s[i-k:i] for i in range(k, len(s)+1)}) == 1 \u003c\u003c k   Binary Trees With Factors  Given an array of unique integers, arr, where each integer arr[i] is strictly greater than 1.\n  We make a binary tree using these integers, and each number may be used for any number of times. Each non-leaf node’s value should be equal to the product of the values of its children.\n  Return the number of binary trees we can make. The answer may be too large so return the answer modulo 10**9+7.\n 1 2 3 4 5 6 7 8 9 10 11  def num_factored_binary_trees(arr: List[int]) -\u003e int: MOD = 10**9 + 7 arr.sort() d = {} for x in arr: d[x] = 1 for y in d: if x % y == 0: d[x] += d[y] * d.get(x // y, 0) d[x] %= MOD return sum(dp.values()) % MOD   Swapping Nodes in a Linked List  Given the head of a linked list, and an integer k.\n  Return the head of the linked list after swapping the values of the k-th node from the beginning the k-th node from the end (the list is 1-indexed).\n  Constraints: 1 \u003c= k \u003c= n (the number of nodes)\n 1 2 3 4 5 6 7 8 9 10 11  def swap_nodes(head: ListNode, k: int) -\u003e ListNode: start = end = cur = head while cur: k -= 1 if k \u003e 0: start = start.next elif k \u003c 0: end = end.next cur = cur.next start.val, end.val = end.val, start.val return head   ","description":"","tags":null,"title":"2021 March Week 2","uri":"/algorithms/challenge/2021-march-week-2/"},{"categories":["Algorithms"],"content":"Distribute Candies  Alice has n candies, where the ith candy is of type candyType[i]. Alice notices that she started to gain weight, so she visited a doctor.\n  The doctor advised Alice to only eat n/2 of the candies she has (n is always even). Alice likes her candies very much, and she wants to eat the maximum number of different types of candies while still following the doctor’s advice.\n  Given the integer array candyType of length n, return the maximum number of different types of candies she can eat if she only eats n/2 of them.\n 1 2  def distribute_candies(candyType: List[int]) -\u003e int: return min(len(candyType)//2, len(set(candyType)))   Set Mismatch  You have a set of integers s, which originally contains all the numbers from 1 to n. Unfortunately, due to some error, one of the numbers in s got duplicated to another number in the set, which results in repetition of one number and loss of another number.\n  You are given an integer array nums representing the data status of this set after the error.\n  Find the number that occurs twice and the number that is missing and return them in the form of an array.\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  def find_error_nums(nums: List[int]) -\u003e List[int]: dup = missing = 0 for x in nums: i = abs(x) - 1 if nums[i] \u003c 0: dup = i + 1 else: nums[i] *= -1 for i, x in enumerate(nums): if x \u003e 0: missing = i + 1 return [dup, missing] def find_error_nums_set(nums: List[int]) -\u003e List[int]: return [sum(nums) - sum(set(nums)), (len(nums)+1)*len(nums)//2 - sum(set(nums))] def find_error_nums_math(nums: List[int]) -\u003e List[int]: # m - t = d, s = m2 - t2 = (m-t)(m+t) = d(m+t) # m = (s/d + d)/2, t = (s/d - d)/2 d = s = 0 for i, x in enumerate(nums): d += i + 1 - x s += (i + 1)**2 - x**2 return [(s//d-d)//2, (s//d+d)//2]   Missing Number  Given an array nums containing n distinct numbers in the range [0, n], return the only number in the range that is missing from the array\n 1 2 3 4 5 6 7 8 9 10 11  def missing_number(nums: List[int]) -\u003e int: return reduce(operator.xor, chain(nums, range(len(nums)+1))) def missing_number_xor(nums: List[int]) -\u003e int: missing = len(nums) for i, x in enumerate(nums): missing ^= i ^ x return missing def missing_number_sum(nums: List[int]) -\u003e int: return (len(nums)+1)*len(nums)//2 - sum(nums)   Intersection of Two Linked Lists  Given the heads of two singly linked-lists headA and headB, return the node at which the two lists intersect. If the two linked lists have no intersection at all, return null.\n  It is guaranteed that there are no cycles anywhere in the entire linked structures.\n 1 2 3 4 5 6  def intersection_node(headA: ListNode, headB: ListNode) -\u003e ListNode: a, b = headA, headB while a != b: a = a.next if a else headB b = b.next if b else headA return a   Average of Levels in Binary Tree  Given the root of a binary tree, return the average value of the nodes on each level in the form of an array. answers with 1e-5 of the actual answer will be accepted.\n 1 2 3 4 5 6 7 8 9 10  def average_of_level(root: TreeNode) -\u003e List[float]: if not root: return [] result = [] level = [root] while level: result.append(sum(n.val for n in level)/len(level)) level = [kid for n in level for kid in (n.left, n.right) if kid] return result   Short Encoding of Words  A valid encoding of an array of words is any reference string s and array of indices indices such that:\n words.length == indices.length The reference string s ends with the # character. for each index indices[i], the substring of s starting from indices[i] and up to (but not including) the next # character is equal to words[i].    Given an array of words, return the length of the shortest reference string s possible of any valid encoding of words.\n 1 2 3 4 5 6 7  def shortest_encoding(words: List[str]) -\u003e int: s = set(words) for word in sorted(words, key=len): if word in s: for i in range(len(word)): s.discard(word[i:]) return sum(len(x)+1 for x in s)   Design HashMap ","description":"","tags":null,"title":"2021 March Week 1","uri":"/algorithms/challenge/2021-march-week-1/"},{"categories":["Algorithms"],"content":"Longest Word in Dictionary through Deleting  Given a string s and a string array dict, return the longest string in the dictionary that can be formed by deleting some of the given string characters. If there is more than one possible result, return the longest word with the smallest lexicographical order. If there is no possible result, return the empty string.\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  def longest_word(s: str, d: List[str]) -\u003e str: def contains(s, word): m, n = len(s), len(word) if m \u003c n: return False i = j = 0 while i \u003c m and j \u003c n: if word[j] == s[i]: j += 1 i += 1 return j \u003e= n d.sort(key=lambda x: (-len(x), x)) for word in d: if contains(s, word): return word return ''   Search a 2D Matrix II  Write an efficient algorithm that searches for a target value in an m x n integer matrix. The matrix has the following properties:\n Integers in each row are sorted in ascending from left to right. Integers in each column are sorted in ascending from top to bottom   1 2 3 4 5 6 7 8 9 10 11 12  def search_matrix(matrix: List[List[int]], target: int) -\u003e bool: m, n = len(matrix), len(matrix[0]) i, j = 0, n-1 while i \u003c m and j \u003e= 0: if matrix[i][j] == target: return True if matrix[i][j] \u003e target: j -= 1 else: i += 1 return False   Score of Parentheses  Given a balanced parentheses string s, compute the score of the string based on the following rule:\n () has score 1. AB has score A + B, where A and B are balanced parentheses strings. (A) has score A * 2, where A is a balanced parentheses string.   1 2 3 4 5 6 7 8 9 10 11  def score_of_parentheses(s: str) -\u003e int: stack = [] for c in s: if c == ')': value = 0 while stack[-1] != '(': value += stack.pop() stack[-1] = value * 2 if value else 1 else: stack.append(c) return sum(stack)   Shortest Unsorted Continuous Subarray  Given an integer array nums, you need to find one continuous subarray that if you only sort this subarray in ascending order, then the whole array will be sorted in ascending order.\n  Return the shortest such subarray and output its length\n 1 2 3  def find_unsorted_subarray(nums: List[int]) -\u003e int: t = [i for i, (x, y) in enumerate(zip(nums, sorted(nums))) if x != y] return t[-1] - t[0] + 1 if t else 0   Validate Stack Sequences  Given two sequences pushed and popped with distinct values, return true if and only if this could have been the result of a sequence of push and pop operations on an initially empty stack.\n 1 2 3 4 5 6 7 8 9  def validate_stack(pushed: List[int], popped: List[int]) -\u003e bool: stack = [] i = 0 for x in pushed: stack.append(x) while stack and stack[-1] == popped[i]: stack.pop() i += 1 return len(popped) == i   Divide Two Integers  Given two integers dividend and divisor, divide two integers without using multiplication, division, and mod operator.\n  Return the quotient after dividing dividend by divisor.\n 1 2 3 4 5 6 7 8 9  def divide(dividend: int, divisor: int) -\u003e int: negative = (dividend \u003c 0) != (divisor \u003c 0) x, y = abs(dividend), abs(divisor) result = 0 for i in range(31, -1, -1): if x \u003e\u003e i \u003e= y: result += 1 \u003c\u003c i x -= y \u003c\u003c i return -result if negative else result   Maximum Frequency Stack  Design a stack-like data structure to push elements to the stack and pop the most frequent element from the stack.\n  Implement the FreqStack class:\n FreqStack() constructs an empty frequency stack. void push(int val) pushes an integer val onto the top of the stack int pop() removes and returns the most frequent element in the stack.  If there is a tie for the most frequent element, the element closet to the stack’s top is removed and returned.     1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  class FreqStack: def __init__(self): self._counter = Counter() self._group = defaultdict(list) self._height = 0 def push(self, x: int) -\u003e None: h = self._counter[x] + 1 self._counter[x] = h self._group[h].append(x) self._height = max(self._height, h) def pop(self) -\u003e int: x = self._group[self._height].pop() self._counter[x] -= 1 if not self.group[self._height]: self._height -= 1 return x   ","description":"","tags":null,"title":"2021 February Week 4","uri":"/algorithms/challenge/2021-february-week-4/"},{"categories":["Algorithms"],"content":"1876. Substrings of Size Three with Distinct Characters  A string is good if there are no repeated characters.\n  Given a string s, return the number of good substrings of length three in s.\n 1 2  def count_good_substrings(s: str) -\u003e int: return sum(1 for i in range(len(s) - 2) if len(set(list(i:i+3))) == 3)   1877. Minimize Maximum Pair Sum in Array  The pair sum of a pair (a, b) is equal to a+b. The maximum pair sum is the largest pair sum in a list of pairs.\n  Given an array nums of even length n, pair up the elements of nums into n/2 pairs such that:\n Each element of nums is in exactly one pair, and The maximum pair sum is minimized. Return the minimized maximum pair sum after optimally pairing up the elements.   1 2 3  def min_max_pair_sum(nums: List[int]) -\u003e int: nums.sort() return max(nums[i] + nums[-1-i] for i in range(len(nums) // 2))   1878. Get Biggest Three Rhombus Sums in a Grid  Given an m x n integer matrix grid.\n  A rhombus sum is the sum of the elements that form the border of a regular rhombus shape in grid. The rhombus must have the shape of a square rotated 45 degrees with each of the corners centered in a grid cell.\n  Return the biggest three distinct rhombus sums in the grid in descending order. If there are less than three distinct values, return all of them.\n 1 2 3 4 5 6  def biggest_three_rhombus_sum(grid: List[List[int]]) -\u003e List[int]: m, n = len(grid), len(grid[0]) prefix = [[0] *(n+2) for _ in range(m+1)] for i in range(m): for j in range(n): prefix[i+1][j+1] = (prefix[i][j] + grid[i][j], prefix[i+2][j] + grid[i][j])   1879. Minimum XOR Sum of Two Arrays  Given two integer arrays nums1 and nums2 of length n.\n  The XOR sum of the two integer arrays is nums1[i] XOR nums2[i] for i -\u003e 0 until n.\n  Rearrange the elements of nums2 such that the resulting XOR sum is minimized.\n  Return the XOR sum after the rearrangement.\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  def min_xor_sum(nums1: List[int], nums2: List[int]) -\u003e int: n = len(nums2) @lru_cache(None) def dfs(i, seen): if i \u003e= n: return 0 result = float('inf') for j in range(n): if (seen \u0026 (1 \u003c\u003c j)) == 0: result = min(result, (nums1[i] ^ nums2[j]) + dfs(i+1, seen | (1 \u003c\u003c j))) return result return dfs(0, 0)   ","description":"","tags":null,"title":"Biweekly Contest 53","uri":"/algorithms/contest/biweekly-contest-53/"},{"categories":["Algorithms"],"content":"The K Weakest Rows in a Matrix  Given an m x n binary matrix mat of 1’s (representing soldiers) and 0’s (representing civilians). The soldiers are positioned in front of the civilians. That is, all the 1’s will appear to the left of all the 0’s in each row. A row i is weaker than a row j if one of the following is true:\n The number of soldiers in row i is less than the number of soldiers in row j. Both rows have the same number of soldiers and i \u003c j. Return the indices of the k weakest rows in the matrix ordered from weakest to strongest.   Solution 1 2  def k_weakest_rows(matrix: List[List[int]], k: int) -\u003e List[int]: return nsmallest(k, range(len(matrix)), key=lambda i: sum(matrix[i]))   Letter Case Permutation  Given a string S, we can transform every letter individually to be lowercase or uppercase to create another string. Return a list of all possible strings we could we could create. You can return the output in any order.\n Solution 1 2 3 4 5 6 7 8  def letter_case_permutation(s: str) -\u003e List[str]: result = [''] for c in S: if c.isdigit(): result = [item + c for item in result] else: result = [item + t for item in result for t in (c.lower(), c.upper())] return result   Container With Most Water  Given n non-negative integers $a_1, a_2, …, a_n$, where each represents a point at coordinate $(i, a_i)$. n vertical lines are drawn such that the two endpoint of the line i is at $(i, a_i)$ and $(i, 0)$. Find two lines, which, together with the x-axis forms a container, such that the container the most water.\n Solution 1 2 3 4 5 6 7 8 9 10  def most_water(heights: List[int]) -\u003e int: start, end = 0, len(heights)-1 result = 0 while start \u003c end: result = max(result, min(heights[start], heights[end]) * (end - start)) if heights[start] \u003e heights[end]: end -= 1 else: start += 1 return result   Arithmetic Slices  An integer array is called arithmetic if it consist of at least three elements and if the difference between any two consecutive elements is the same.\n For example, [1,3,5,7,9], [7,7,7,7] and [3,-1,-5,-9] are arithmetic sequences. Given an integer array nums, return the number of arithmetic subarray of nums.   Solution 1 2 3 4 5 6 7 8 9 10 11  def arithmetic_slices(nums: List[int]) -\u003e int: result = 0 delta = [nums[i+1] - nums[i] for i in range(len(nums) - 1)] for _, part in groupby(delta): n = len(part) if n \u003e 1: result += n * (n-1) // 2 return result def arithmetic_slices(nums: List[int]) -\u003e int:   Minimum Remove to Make Valid Parentheses  Given a string of (,) and lowercase English characters. You task is to remove the minimum number of parentheses ('(', ')', in any positions) so that the result parentheses string is valid amd return any valid string.\n Solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  def minimum_remove_to_make_valid(s: str) -\u003e str: result = list(s) left = [] for i, c in enumerate(result): if c == '(': left.append(i) elif c == ')': if left: left.pop() else: result[i] = '' while left: result[left.pop()] = '' return ''.join(result)   Roman to Integer  Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M. Given a roman numeral [1, 3999], convert it to an integer.\n Solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  def roman_to_int(r: str) -\u003e int: R = { \"I\": 1, \"V\": 5, \"X\": 10, \"L\": 50, \"C\": 100, \"D\": 500, \"M\": 1000 } result = 0 prev = 1000 for c in r: result += d[c] if prev \u003c d[c]: result -= prev * 2 prev = d[c] return result   Broken Calculator  On a broken calculator that has a number showing on its display, we can perform two operations:\n Double: Multiply the number on the display by 2, or; Decrement: Subtract 1 from the number on the display. Return the minimum number of operation of operations needed to display the number Y from the initial value X.   Solution 1 2 3 4 5 6 7 8 9 10  def broken_calculator(x: int, y: int) -\u003e int: result = 0 while x \u003c y: result += 1 if y % 2: y += 1 # decrement else: y //= 2 return result + x - y   ","description":"","tags":null,"title":"2021 February Week 3","uri":"/algorithms/challenge/2021-february-week-3/"},{"categories":["Algorithms"],"content":"Peeking Iterator  Design an iterator that supports the peek operation on a list in addition to the hasNext and the next operations. Implement the PeekingIterator class:\n PeekingIterator(int[] nums) Initializes the object with the given integer array nums`. int next() Returns the next elements in the array and moves the pointer to the next element. bool hasNext() Returns true if there are still elements in the array. int peek() Returns the next element in the array without moving the pointer.   Solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  # class Iterator: # def __init__(self, nums): # pass #  # def hashNext(self): # pass #  # def next(self): # pass class PeekingIterator: def __init__(self, iterator): self.__it = iterator self.__value = self.__it.next() if self.__it.hasNext() else None def peek(self): return self.__value def next(self): result = self.__value self.__value = self.__it.next() if self.__it.hashNext() else None def hasNext(self): return self.__value is not None   Convert BST to Greater Tree  Given the root of a Binary Search Tree (BST), convert it to a Greater Tree such that every key of the original BST is changed to the original key plus sum of all keys greater than the original key in BST.\n  As a reminder, a binary search tree is a tree that satisfies these constraints:\n The left subtree of a node contains only nodes with keys less than the node’s key. The right subtree of a node contains only nodes with keys greater than the node’s key. Both the left and right subtrees must also be binary search trees.   Solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  def solve(root: TreeNode) -\u003e TreeNode: value = 0 node = root stack = [] while stack or node: if node: stack.append(node) node = node.right else: node = stack.pop() value += node.val node.val = value node = node.left return root def solve(root: TreeNode) -\u003e TreeNode: def dfs(node, value): if not node: return value value = dfs(node.right, value) node.val += value return dfs(node.left, node.val) dfs(root, 0) return root   Copy List with Random Pointer Solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  # class Node: # def __init__(self, x: int, next: Node=None, random: Node=None): # self.x = x # self.next = next # self.random = random def solve(head: Node) -\u003e Node: if not head: return None cur = head while cur: cur.next = Node(cur.x, cur.next, cur.random) cur = cur.next.next cur = head while cur: cur.next.random = cur.random.next if cur.random else None cur = cur.next.next cur = head.next while cur: cur.next = cur.next.next if cur.next else None cur = cur.next return head.next   Valid Anagram  Given two strings s and t, return true if t is an anagram of s, and false otherwise.\n 1 2 3  def solve(s: str, t: str) -\u003e bool: return sorted(s) == sorted(t) # return Counter(s) == Counter(t)   Number of Steps to Reduce a Number to Zero  Given a non-negative integer num, return the number of steps to reduce it to zero. If the current number is even, you have to divide it by 2, otherwise, you have to subtract 1 from it.\n Solution 1 2 3 4 5 6  def solve(num: int) -\u003e int: result = 0 while num: num = num - 1 if num % 2 else num // 2 result += 1 return result   Shortest Path in Binary Matrix  Given an n x n binary matrix grid, return the length of the shortest clear path in the matrix. If there is no clear path, return -1. A clear path in a binary matrix is a path from the top-left cell (i.e., (0, 0)) to the bottom-right cell (i.e., (n-1, n-1)) such that:\n All the visited cells of the path are 0. All the adjacent cells of the path are 8-directionally connected (i.e., they are different and they share an edge or a corner). The length of a clear path is the number of visited cells of this path.   Solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  def solve(grid: List[List[int]]) -\u003e int: if grid[0][0] == 1 or grid[-1][-1] == 1: return -1 DIR = ((1,0),(1,1),(1,-1),(0,1),(0,-1),(-1,1),(-1,0),(-1,-1)) n = len(grid) queue = deque([(0, 0, 1)]) while queue: x, y, d = queue.popleft() if x == y == n-1: return d for dx, dy in DIR: i, j = x+dx, y+dy if 0 \u003c= i \u003c n and 0 \u003c= j \u003c n and grid[i][j] == 0: grid[i][j] = 1 queue.append((i, j, d+1)) return -1   Is Graph Bipartite?  There is an undirected graph with n nodes, where each node is numbered between 0 and n-1. You are given a 2D array graph, where graph[u] is an array of nodes that node u is adjacent to. More formally, for each v in graph[u], there is an undirected edge between node u and node v. The graph has the following properties:\n There are no self-edges (graph[u] does not contain u). There are no parallel edges (graph[u] does not contain duplicate values). If v is in graph[u], then u is in graph[v] (the graph is undirected). The graph may not be connected, meaning there may be two nodes u and v such that there is no path between them.    A graph is bipartite if the nodes can be partitioned into two independent sets A and B such that every edge in the graph connects a node in set A and a node in set B.\n  Return true if and only if it is bipartite.\n Solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  def is_bipartite(graph: List[List[int]]) -\u003e bool: n = len(graph) color = [0] * n for i in range(n): if color[i]: continue queue = deque([i]) color[i] = 1 while queue: v = queue.popleft() for u in graph[v]: if color[u] == color[v]: return False if color[u] == 0: color[u] = -color[v] queue.append(u) return True   ","description":"","tags":null,"title":"2021 February Week 2","uri":"/algorithms/challenge/2021-february-week-2/"},{"categories":["Algorithms"],"content":"Longest Harmonious Subsequence  Defined a harmonious array as an array where the difference between its maximum value and its minimum value is exactly 1.\nGiven an integer array nums, return the length of its longest harmonious subsequence among all its possible subsequences.\n Intuition Solution 1 2 3  def solve(nums: List[int]) -\u003e int: counter = Counter(nums) return max(counter[k] + counter[k-1] for k in counter if k-1 in counter, default = 0)   Simplify Path  Given a string path, which is an absolute path (starting with a slash '/') to a file or directory in a Unix-style file system, convert it to the simplified canonical path.\n Solution 1 2 3 4 5 6 7 8 9 10  def solve(path: str) -\u003e str: items = path.split('/') result = [] for item in items: if item == '..': if result: result.pop() elif item != '.' and item != '': result.append(item) return '/' + '/'.join(result)   Binary Tree Right Side View  Given the root of a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.\n Solution 1 2 3 4 5 6 7 8 9 10  def solve(root: TreeNode) -\u003e List[int]: if not root: return [] result = [] level = [root] while level: result.append(level[-1].val) level = [kid for node in level for kid in (node.left, node.right) if kid] return result   Shortest Distance to a Character  Given a string s and a character c that occurs in s, return an array of integers answer where answer.length == s.length and answer[i] is the distance from index i to the closest occurrence of character c in s.\n Intuition Solution 1 2 3 4 5 6 7 8 9 10 11 12 13  def solve(s: str, c: str) -\u003e List[int]: prev = float('-inf') n = len(s) result = [n] * n for i in range(n): if s[i] == c: prev = i result[i] = min(result[i], i - prev) for i in range(n-1, -1, -1): if s[i] == c: prev = i result[i] = min(result[i], prev - i) return result   ","description":"","tags":null,"title":"2021 February Week 1","uri":"/algorithms/challenge/2021-february-week-1/"},{"categories":["Algorithms"],"content":"Vertical Order Traversal of a Binary Tree  Given the root of a binary tree, calculate the vertical order traversal of the binary tree.\nNote: There may be multiple nodes in the same row and same column. In such a case, sort these nodes by their values.\n Solution 1 2 3 4 5 6 7 8 9 10 11 12 13  def solve(root: ListNode) -\u003e List[List[int]]: level = [(root, 0)] columns = defaultdict(list) while level: for c, val in sorted([(c, node.val) for node, c in level]): columns[c].append(val) level = [ (kid, t) for node, c in level for kid, t in ((node.left, c-1), (node.right, c+1)) if kid ] return [columns[c] for c in sorted(columns.keys())]   Minimize Deviation in Array  Given an array nums of n positive integers. You can perform two types of operations on any element of the array any number of times:\n If the element is even, divide it by 2. If the element is odd, multiply it by 2.  The deviation of the array is the maximum difference between any two elements in the array.\nReturn the minimum deviation the array can have after performing some number of operations.\n Solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  def solve(nums: List[int]) -\u003e int: heap = [] for x in nums: temp = x while temp % 2 == 0: temp //= 2 heappush(heap, (temp, max(x, temp*2))) lower = max(i for i, _ in heap) result = float('inf') while len(heap) == len(nums): x, upper = heappop(heap) result = min(result, lower - x) if x \u003c upper: heappush(heap, (x*2, upper)) lower = max(lower, x*2) return result   Next Permutation  Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.\nIf such an arrangement is not possible, it must rearrange it as the lowest possible order (i.e., sorted in ascending order).\nThe replacement must be in place and use only constant extra memory.\n Solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  def solve(nums: List[int]) -\u003e None: i = len(nums)-2 while i \u003e -1 and nums[i] \u003e= nums[i+1]: i -= 1 if i == -1: nums.reverse() return j = len(nums) -1 while nums[j] \u003c= nums[i]: j -= 1 nums[i], nums[j] = nums[j], nums[i] start, end = i+1, len(nums)-1 while start \u003c end: nums[start], nums[end] = nums[end], nums[start] start, end = start+1, end-1   ","description":"","tags":null,"title":"2021 January Week 5","uri":"/algorithms/challenge/2021-january-week-5/"},{"categories":["Algorithms"],"content":"Determine if Two Strings Are Close  Two strings are considered close if you can attain one from the other using the following operations:\n Operation 1: Swap any two existing characters. eg. abcde -\u003e aecdb, (b \u003c-\u003e e) Operation 2: Transform every occurrence of one existing character into another existing character, and do the same with the other character. eg. aacabb -\u003e bbcbaa (a \u003c-\u003e b).  You can use the operations on either string as many times as necessary.\nGiven two strings, word1 and word2, return true if word1 and word2 are close, and false otherwise.\n Solution 1 2 3 4 5 6 7  def solve(s: str, t: str) -\u003e bool: cs = Counter(s) ct = Counter(t) return ( sorted(cs.keys()) == sorted(ct.keys()) and sorted(cs.values()) == sorted(ct.values()) )   Sort the Matrix Diagonally  A matrix diagonal is a diagonal line of cells starting from some cell in either the topmost row or leftmost column and going in the bottom-right direction until reaching the matrix’s end. For example, the matrix diagonal starting from mat[2][0], when mat is a 6x3 matrix, includes cells mat[2][0], mat[3][1] and mat[4][2].\nGiven an m x n matrix mat of integers, sort each matrix diaginal in ascending order and return the resulting matrix.\n Solution 1 2 3 4 5 6 7 8 9 10 11  def solve(mat: List[List[int]]) -\u003e List[List[int]]: m, n = len(mat), len(mat[0]) diagonal = defaultdict(list) for i in range(m): for j in range(n): insort(diagonal[i-j], mat[i][j]) for i in range(m): for j in range(n): mat[i][j] = diagonal[i-j].pop(0) return mat   Merge k Sorted Lists  Given an array of k linked-lists lists, each linked-list is sorted in ascending order.\nMerge all the linked-lists into one sorted linked-list and return it.\n Solution 1 2 3 4 5 6 7 8 9 10 11 12  def solve(lists: List[ListNode]) -\u003e ListNode: heap = [] for head in lists: heappush(heap, (head.val, i, head)) c = dummy = ListNode() while heap: _, i, c.next = heappop(heap) c = c.next if c and c.next: heappush(heap, (c.next.val , i, c.next)) return dummy.next   Check if All 1’s Are at Least Length K Places Away  Given an array nums of 0s and 1s and an integer k, return True if all 1s are a least k places away from each other, otherwise return False.\n Solution 1 2 3 4 5 6 7 8  def solve(nums: List[int], k: int) -\u003e bool: prev = float('-inf') for i, x in enumerate(nums): if x: if i - prev \u003c= k: return False prev = i return True   Path with Minimum Effort  You are a hiker preparing for an upcoming hike. You are given heights, a 2D array of size rows x columns, where heights[row][col] represents the height of cell (row, col). You are situated in the top-left cell, (0, 0), and you hope to trvel to the bottom-right cell, (rows-1, columns-1). You can move up, down, left, or right, and you wish to find a route that requires the minimum effort.\nA route’s effort is the maximum absolute difference in heights between two consecutive cells of the route.\nReturn the minimum effort required to travel from the top-left cell to the bottom-right cell.\n Solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42  def solve(heights: List[List[int]]) -\u003e int: DIR = ((1, 0), (-1, 0), (0, 1), (0, -1)) m, n = len(heights), len(heights[0]) distance = [[float('inf')] * n for _ in range(m)] heap = [(0, 0, 0)] # distance, i, j while heap: d, r, c = heappop(heap) if d \u003e distance[r][c]: continue if r == m-1 and c == n-1: return d for dr, dc in DIR: x, y = r+dr, c+dc if 0 \u003c= x \u003c m and 0 \u003c= y \u003c n: temp = max(d, abs(heights[x][y] - heights[r][c])) if distance[x][y] \u003e temp: distance[x][y] = temp heappush(heap, (distance[x][y], x, y)) def solve2(heights: List[List[int]]) -\u003e int: DIR = ((1, 0), (-1, 0), (0, 1), (0, -1)) m, n = len(heights), len(heights[0]) def dfs(limit, r, c): for dr, dc in DIR: x, y = r+dr, c+dc if 0 \u003c= x \u003c m and 0 \u003c= y \u003c n and (x, y) not in seen and abs(heights[x][y] - heights[r][c]) \u003c= limit: seen.add((x, y)) if x == m-1 and y == n-1: return dfs(limit, x, y) start, end = 0, max(max(heights, key=max)) while start \u003c end: mid = (start + end) // 2 seen = {(0, 0)} dfs(mid, 0, 0) if (m-1, n-1) in seen: end = mid else: start = mid + 1 return end   Concatenation of Consecutive Binary Numbers  Given an integer n, return the decimal value of the binary string formed by concatenating the binary representations of 1 to n in order, modulo 10**9+7.\n Solution 1 2 3 4 5 6 7 8 9 10 11  def solve(n: int) -\u003e int: return int(''.join(bin(i)[2:] for i in range(1, n+1)), 2) % (10**9 + 7) def solve2(n: int) -\u003e int: MOD = 10**9 + 7 result = shift = 0 for i in range(1, n+1): if i \u0026 (i-1) == 0: shift += 1 result = (result \u003c\u003c shift + i) % MOD return result   Smallest String with a Given Numeric Value  The numeric value of a lowercase character is defined as its position (1-indexed) in the alphabet, so the numeric value of a is 1, the numeric value of b is 2, the numeric value of c is 3, and so on.\nThe numeric value of a string consisting of lowercase characters is defined as the sum of its characters' numeric values. For example, the numeric value of the string \"abc\" is equal to 1+2+5=8.\nYou are given two integers n and k. Return the lexicographically smallest string with length equal to n and numeric value equal to `k.\nNote that a string x is lexicographically smaller than string y if x comes before y in dictionary order, that is, either x is prefix of y, or if i is the first position such that x[i] != y[i], then x[i] comes before y[i] in alphabetic order.\n Solution 1 2 3 4 5  def solve(n: int, k: int) -\u003e str: z, rem = divmod(k - n, 25) if rem: return 'a' * (n-z-1) + chr(97 + rem) + 'z' * z return 'a' * (n-z) + 'z' * z   ","description":"","tags":null,"title":"2021 January Week 4","uri":"/algorithms/challenge/2021-january-week-4/"},{"categories":["Algorithms"],"content":"Get Maximum in Generated Array  Given an integer n. An Array nums of length n+1 is generated in the following way:\n nums[0] = 0 nums[1] = 1 nums[2i] = nums[i], when `2 \u003c= 2i \u003c= n nums[2i + 1] = nums[i] + nums[i+1], when `2 \u003c= 2i + 1 \u003c= n  Return the maximum integer in the array nums.\n Solution 1 2 3 4 5 6 7 8 9 10 11 12 13  def solve(n): if n \u003c 2: return n x = [0] * (n + 1) x[1] = 1 for i in range(2, n): j, odd = divmod(i, 2) if odd: x[i] = x[j] + x[j+1] else: x[i] = x[j] result = max(result, x[i]) return result   Kth Largest Element in an Array  Given an integer array nums and an integer k, return the kth largest element in the array.\n Solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  def solve(nums: List[int], k: int) -\u003e int: return nlargest(k, nums)[-1] def solve2(nums: List[int], k: int) -\u003e int: start, end = 0, len(nums) while start \u003c end: p = randint(start, end-1) nums[p], nums[end-1] = nums[end-1], nums[p] i = start for j in range(start, end-1): if nums[j] \u003e nums[i]: nums[i], nums[j] = nums[j], nums[i] i += 1 nums[i], nums[end-1] = nums[end-1], nums[i] if i == k - 1: return nums[i] elif i \u003e k - 1: end = i else: start = i + 1   Count Sorted Vowel Strings  Given an integer n, return the number of strings of length n that consist only of vowels (a, e, i, o, u) and are lexicographically sorted.\nA string s is lexicographically sorted if for all valid i, s[i] is the same as or comes before s[i+1] in the alphabet.\n Solution 1 2 3 4 5  def solve(n: int) -\u003e int: a = e = o = i = u = 1 for _ in range(n): a, e, i, o, u = a+e+i+o+u, e+i+o+u, i+o+u, o+u, u return a   Max Number of K-Sum Pairs  Given an integer array nums and an integer k.\nIn one operation, you can pick two numbers from the array whose sum equals k and remove them from array.\nReturn the maximum number of operations you can perform on the array.\n Solution 1 2 3 4 5 6 7 8 9 10  def solve(nums: List[int], k: int) -\u003e int: result = 0 d = defaultdict(int) for x in nums: if d[x] \u003e 0: result += 1 d[x] -= 1 else: d[k - x] += 1 return result   Longest Palindromic Substring  Given a string s, return the longest palindromic substring in s.\n 1 2 3 4 5 6 7 8 9 10  def solve(s: str) -\u003e str: def palindromic(i: int, j: int) -\u003e str: while 0 \u003c i and j \u003c len(s) and s[i] == s[j]: i, j = i-1, j+1 return s[i+1:j] result = '' for i in range(len(s)): result = max(result, palindromic(i, i), palindromic(i, i+1), key=len) return result   Valid Parentheses  Given a string s containing just the characters (, ), {, }, [ and ], determine if the input string is valid. An input string is valid if:\n Open brackets must be closed by the same type of brackets. Open brackets must be closed in the correct order.   1 2 3 4 5 6 7 8 9 10 11 12  def solve(s: str) -\u003e bool: brackets = {')': '(', ']': '[', '}': '{'} stack = [] for c in s: if c in brackets: if stack and stack[-1] == brackets[c]: stack.pop() else: return False else: stack.append(c) return not stack   Find the Most Competitive Subsequence  Given an integer array nums and a positive integer k, return the most competitive subsequence of nums of size k.\nAn array’s subsequence is a resulting sequence obtained by erasing some (possibly zero) elements from the array.\nWe define that a subsequence a is more competitive than a subsequence b (of the same length) if in the first position where a and b differ, subsequence a has a number less than the corresponding number in b. For example, [1,3,4] is more competitive than [1,3,5] because the first position they differ is at the final number and 4 is less than 5.\n Solution 1 2 3 4 5 6 7 8 9  def solve(nums: List[int], k: int) -\u003e List[int]: n = len(nums) stack = [] for i, x in enumerate(nums): while stack and stack[-1] \u003e x and len(stack) - 1 + n - i \u003e= k: stack.pop() if len(stack) \u003c k: stack.append(x) return stack   ","description":"","tags":null,"title":"2021 January Week 3","uri":"/algorithms/challenge/2021-january-week-3/"},{"categories":["Algorithms"],"content":"","description":"","tags":null,"title":"Weekly Contest 223","uri":"/algorithms/contest/weekly-contest-223/"},{"categories":null,"content":"Check If Two String Arrays are Equivalent  Given two strings s and t, return true if the two arrays represent the same string, and false otherwise.\nA string is represented by an array if the array elements concatenated in order forms the string.\n Intuition Solution 1 2 3  def solve(s: List[str], t: List[str]) -\u003e bool: return all(i == j for i, j in zip_longest(chain(*s), chain(*t)) # return ''.join(s) == ''.join(t)   Word Ladder  A transformation sequence from word beginWord to word endWord using a dictionary wordList is a sequence of words beginWord -\u003e s1 -\u003e s2 -\u003e ... -\u003e sk, such that:\n Every adjacent pair of words differs by a single letter. Every si for 1 \u003c= i \u003c= k is in wordList. Note that beginWord does not need to be in wordList. sk == endWord  Given two words, beginWord and endWord, and a dictionary wordList, return the number of words in the shortest transformation sequence from beginWord to endWord, or 0 if no such sequence exists.\n Intuition Solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  def solve(words: List[str], begin: str, end: str) -\u003e int: if end not in words: return 0 aux = defaultdict(set) for w in words: for i in range(len(w)): key = w[0:i] + '?' + w[i+1:] aux[key].add(w) candidate = deque([(begin, 1)]) seen = {begin} while candidate: word, depth = candidate.popleft() for i in range(len(word)): key = word[0:i] + '?' + word[i+1:] for w in aux[key]: if w == end: return depth + 1 if w not in seen: seen.add(w) candidate.append((w, depth+1)) return 0   Create Sorted Array through Instructions  Given an integer array instructions, you are asked to create a sorted array from the elements in instructions. You start with an empty container nums. For each element from left to right in instructions, insert it into nums. The costof each insertion is the minimum of the following:\n The number of elements currently in nums that are strictly less than instructions[i]. The number of elements currently innums that are strictly greater than instructions[i].  For example, if inserting element 3 into nums = [1,2,3,5], the cost of insertion is min(2,1) (element1 1 and 2 are less than 3, element 5 is greater than 3) and nums will become [1,2,3,3,5]. Return the total cost to insert all elements from instructions into nums. Since tha answer may be large, return it modulo 10**9 + 7.\n Solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41  def solve(instructions: List[int]) -\u003e int: MOD = 10**9 + 7 result = 0 aux = [] for i, x in enumerate(instructions): left, right = bisect_left(aux, x), bisect_right(aux, x) result += min(left, i - right) aux[right:right] = [x] # aux.insert(right, x) # insort(aux, x) return result % MOD class Bit: def __init__(self, n): self.__n = n self.__bit = [0] * (n + 1) def query(self, x): result = 0 while x \u003e 0: result += self.__bit[x] x -= -x \u0026 x return result def update(self, x): while x \u003c= self.__n: self.__bit[x] += 1 x += -x \u0026 x def solve2(instructions: List[int]) -\u003e int: MOD = 10**9 + 7 n = max(instructions) bit = Bit(n) result = 0 for i, n in enumerate(instructions): result += min(bit.query(n-1), i - bit.query(n)) bit.update(n) return result % MOD   Merge Sorted Array  Given two sorted integer nums1 and nums2, merge nums2 into nums1 as one sorted array.\n Intuition Solution 1 2 3 4 5 6 7 8 9 10 11 12  def solve(nums1: List[int], m: int, nums2: List[int], n: int) -\u003e None: end = m + n while m and n: if nums1[m-1] \u003e nums1[n-1]: nums1[end-1] = nums1[m-1] end, m = end-1, m-1 else: nums1[end-1] = nums2[n-1] end, n = end-1, n-1 while n \u003e 0: nums1[end-1] = nums2[n-1] end, n = end-1, n-1   Add Two Numbers  Given two non-empty linked lists representing two non-negative integers. The digits are stored in reversed order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\n Intuition Solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14  def solve(s: ListNode, t: ListNode) -\u003e ListNode: c = dummy = ListNode() carry = 0 while s or t or carry: if s: carry += s.val s = s.next if t: carry += t.val t = t.next carry, digit = divmod(carry, 10) c.next = ListNode(val=digit) c = c.next return dummy.next   Boats to Save People  Given an array people where people[i] is the weight of the ith person, and an infinite number of boats where each boat can carry a maximum weigth of limit. Each boat carries at most two people at the same time, provided the sum of the weight of those people is at most limit. Return the minimum number of boats to carry every given person.\n Intuition Solution 1 2 3 4 5 6 7 8 9 10  def solve(people: List[int], limit: int) -\u003e int: people.sort() result = 0 start, end = 0, len(people) - 1 while start \u003c= end: if people[start] + people[end] \u003c= limit: start += 1 end -= 1 result += 1 return result   Minimum Operations to Reduce X to Zero  Given a positive integer array nums and an integer x. In one operation, you can either remove the leftmost or the rightmost element from the array nums and subtract its value from x. Note that this modifies the array fro future operations. Return the minimum number of operations to reduce x to exactly 0 if it’s possible, otherwise, return -1. Constraints\n  1 \u003c= nums.length \u003c= 10**5  Intuition First, solving this problem using DP, but then realized that the constraints are too large.\nThen, thinking in reverse, that, instead of finding the minimum prefix + suffix, find the maximum subarray.\nFinal, finding the maximum subarray is standard and can be done greedily.\nSolution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  def solve(nums: List[int], x: int) -\u003e int: target = sum(nums) - x if target \u003c 0: return -1 n = len(nums) if target == 0: return n result = total = j = 0 for i in range(len(nums)): total += nums[i] while total \u003e target: total -= nums[j] j += 1 if total == target: result = max(result, i - j + 1) return n - result if result else -1   ","description":"","tags":null,"title":"2021 January Week 2","uri":"/algorithms/challenge/2021-january-week-2/"},{"categories":["Algorithms"],"content":"Remove Duplates from Sorted Array  Given a sorted array nums, remove the duplicates in-place such that each element appears only once and returns the new length.\nDo not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.\n 1 2 3 4 5 6 7 8  def solve(nums): offset = 0 for x in nums: if x != nums[offset]: offset += 1 nums[offset] = x return offset + 1 if nums else 0   Best Time to Buy and Sell Stock II  You are given an array prices where prices[i] is the price of a given stock on the ith day.\nFind the maximum profit you can achieve. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times).\nNote: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).\n 1 2 3 4 5 6 7  def slove(prices): profit, n = 0, len(prices) for i in range(1, n): delta = prices[i] - prices[i-1] if delta \u003e 0: profit += delta return profit   ","description":"","tags":null,"title":"Top Easy","uri":"/algorithms/ds/array/top-easy/"},{"categories":["Algorithms","LeetCode"],"content":"Problem  You are given an array of binary strings strs and two integers m and n. Return the size of the largest subset of strs such that there are at most m 0’s and n 1’s in the subset. A set x is a subset of a set y if all elements of x are also elements of y.\n  Constraints:\n `1 \u003c= strs.length \u003c= 600 `1 \u003c= strs[i].length \u003c= 100 str[i] consists only of digits '0' and '1'. 1 \u003c= m, n \u003c= 100   Code 1 2 3 4 5 6 7  def ones_and_zeroes(strs: List[str], m: int, n: int) -\u003e int: seen = {(0, 0, 0)} # num, zero, one for s in strs: z = s.count('0') o = len(s) - z seen |= {(num+1, zero+z, one+o) for num, zero, one in seen if zero + z \u003c= m and one + o \u003c= n} return max(seen)[0]   1 2 3 4 5 6 7 8 9 10 11 12  def ones_and_zeroes(strs: List[str], m: int, n: int) -\u003e int: @lru_cache(None) def dfs(num, zero, one): if zero \u003c 0 or n \u003c 0: return -float('inf') if num == len(strs): return 0 z = strs[num].count('0') o = len(strs[num]) - z return max(dfs(num+1, zero, one), 1 + dfs(num+1, zero-z, one-o)) return dfs(0, m, n)   ","description":"","tags":["BFS","DFS"],"title":"Ones and Zeroes","uri":"/algorithms/2021/04/02/ones-and-zeroes/"},{"categories":["Algorithms","LeetCode"],"content":"Problem  Given the head of a singly linked list, return true if it is a palindrome.\n  Constraints:\n The number of nodes in the list is in the range [1, 10**5] 0 \u003c= Node.val \u003c= 9   Intuition We’d use two pointers for checking whether an array is a palindrome. so that, we need to find the terminal node (the middle node in this case) and the tail node.\nTo find the middle node, we use the fast-slow pointers, the fast pointer iterates twice while the slow one iterates one. The time compexity is O(n).\nTo compare the head and the tail nodes, we need to reverse the right part. The time is O(n)\nFinally, we iterate and compare the head and the tail nodes, The time is also O(n).\nIn total, the time is O(n) and the space is O(1).\nCode 1 2 3 4 5 6 7 8 9 10 11 12 13 14  def palindrome_linked_list(head: ListNode) -\u003e bool: fast = mid = head while fast and fast.next: fast, mid = fast.next.next, mid.next right = None while mid: mid.next, right, mid = right, mid, mid.next while head and right: if right.val != head.val: return False head, right = head.next, right.next return True   ","description":"","tags":["Two Pointers"],"title":"Palindrome Linked List","uri":"/algorithms/2021/04/01/palindrome-linked-list/"},{"categories":["Algorithms","LeetCode"],"content":"Distribute Candies  Alice has n candies, where the ith candy is of type candyType[i]. Alice notices that she started to gain weight, so she visited a doctor.\n  The doctor advised Alice to only eat n/2 of the candies she has (n is always even). Alice likes her candies very much, and she wants to eat the maximum number of different types of candies while still following the doctor’s advice.\n  Given the integer array candyType of length n, return the maximum number of different types of candies she can eat if she only eats n/2 of them.\n 1 2  def distribute_candies(candyType: List[int]) -\u003e int: return min(len(candyType)//2, len(set(candyType)))   ","description":"","tags":["Set"],"title":"Distribute Candies","uri":"/algorithms/2021/03/01/distribute-candies/"},{"categories":["Algorithms","LeetCode"],"content":"Linked List Cycle Given head, the head of a linked list, determine if the linked list has a cycle in it.\nReturn true if there is a cycle in the linked list. Otherwise, return false.\nIntuition If there is a cycle in the linked list cycle, the fast pointer will meet the slow pointer. Otherwise, the fast will hit the end None.\nSolution 1 2 3 4 5 6 7  def solve(head: ListNode) -\u003e bool: fast = slow = head while fast and fast.next: fast, slow = fast.next.next, slow.next if fast == slow: return True return False   ","description":"","tags":["Linked List","Two Pointers"],"title":"Linked List Cycle","uri":"/algorithms/2021/02/03/linked-list-cycle/"},{"categories":["Algorithms","LeetCode"],"content":"Trim a Binary Search Tree  Given the root of a binary search tree and the lowest and highest boundaries as low and high, trim the tree so that all its elements lies in [low, high]. Trimming the tree should not change the relative structure of the elements that will remain in the tree (i.e., any node’s descendant should remain a descendant). It can be proven that there is a unique answer.\nReturn the root of the trimmed binary search tree. Note that the root may change depending on eht given bounds.\n Intuition if the value of a node is less than low, use the right kid instead of the left. if the value of a node is greater than high, use the left kid instead of the right.\nSolution 1 2 3 4 5 6 7 8 9 10  def solve(root: TreeNode, low: int, high: int) -\u003e TreeNode: if not root: return None if root.val \u003c low: return solve(root.right, low, high) if root.val \u003e high: return solve(root.left, low, high) root.left = solve(root.left, low, high) root.right = solve(root.right, low, high) return root   ","description":"","tags":["DFS"],"title":"Trim a Binary Search Tree","uri":"/algorithms/2021/02/02/trim-a-binary-search-tree/"},{"categories":["Algorithms","LeetCode"],"content":"Number of 1 bits  Write a function that takes an unsigned integer and returns the number of 1 bits it has (also know as the Hamming weight).\n Intuition Use x \u0026 (x-1) remove the rightmost 1 bit.\nSolution 1 2 3 4 5 6  def count_1s(n: int) -\u003e int: result = 0 while n: result += 1 n \u0026= n-1 return result   ","description":"","tags":["bit"],"title":"01 Number of 1 Bits","uri":"/algorithms/2021/02/01/number-of-1-bits/"},{"categories":["Algorithms"],"content":"Maximum (Minimum) Path to Reach a Target Statement:\n Given a target find maximum (minimum) cost/path/sum to reach a target. Approach: Choose minimum (maximum) path among all possible paths before the current state, then add the current value. routes[i] = max(routes[j] for j in range(k, i-1)) + values[i]\n Min Cost Climbing Stairs LC746  Given a staircase, the i-th step has some non-negative cost cost[i]. You can either climb one or two steps, find minimum cost to reach the top of the staircase.\n 1 2 3 4 5  def solve(cost): s = t = 0 for x in cost: s, t = x + min(s, t), s retur min(s, t)   Minimum Path Sum LC64  Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path. You can only move either down or right at any point in time.\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14  def solve(grid): \"\"\" dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + cost \"\"\" m, n = len(grid), len(grid[0]) for i in range(m): grid[i][0] += grid[i-1][0] for j in range(n): grid[0][j] += grid[0][j-1] for i in range(1, m): for j in range(1, n): grid[i][j] += min(grid[i][j-1], grid[i-1][j]) return grid[-1][-1]   Coin Change LC322  Given coins of different denominations and a total amount of money amount. Return the fewest number of coins that you need to make up that amount. If that amount of money cannot made up, return -1. You may assume that you have an infinite number of each kind of coin.\n 1 2 3 4 5 6 7  def solve(coins, amount): dp = [0] + [-1] * amount for i in range(1, amount + 1): options = [dp[i-c] + 1 for c in coins if i \u003e= c and dp[i-c] \u003e -1] if options: dp[i] = min(options) return dp[-1]   1 2 3 4 5 6 7 8 9 10 11 12 13  def solve(coins, amount): dp = [0] + [-1] * amount queue = deque([0]) while queue: v = queue.popleft() for c in coins: j = c + v if j \u003c= amount and dp[j] == -1: dp[j] = 1 + dp[v] if j == amount: return dp[-1] queue.append(c + v) return dp[-1]   Minimum Falling Path Sum  Given a square array of integers grid, we want the minimum sum of a falling path through grid. A falling path starts at any element in the first row, and choose one element from each row. The next row’s choice must be in a column that is different from the previous row’s column by at most one.\n 1 2 3 4 5 6  def solve(grid): m, n = len(grid), len(grid[0]) for i in range(1, m): for j in range(n): grid[i][j] += min(grid[i-1][k] for k in range(j-1, j, j+1) if 0 \u003c= k \u003c n) return min(grid[-1])   ","description":"","tags":null,"title":"Reach Target","uri":"/algorithms/dynamic-programming/reach-target/"},{"categories":null,"content":"Number of Islands  Given an m x n 2d grid map of '1's (land) and '0's (water), return the number of islands. Assume all four edges of the grid are surrounded by water.\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  def solve(grid): result = 0 m, n = len(grid), len(grid[0]) for i in range(m): for j in range(n): if grid[i][j] == '1': result += 1 queue = deque([(i, j)]) grid[i][j] = '' while queue: x, y = queue.popleft() for dx, dy in ((-1, 0), (1, 0), (0, -1), (0, 1)): if 0 \u003c= x+dx \u003c m and 0 \u003c= y+dy \u003c n and grid[x+dx][y+dy] == '1': queue.append((x+dx, y+dy)) grid[x+dx][y+dy] = '' return result   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  def solve(grid): def dfs(grid, i, j): if grid[i][j] == '0': return grid[i][j] = '0' if i \u003e 0: dfs(grid, i-1, j) if j \u003e 0: dfs(grid, i, j-1) if i \u003c len(grid): dfs(grid, i+1, j) if i \u003c len(grid[0]): dfs(grid, i, j+1) result = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == '1': dfs(grid, i, j) result += 1 return result   Max Area of Island  Given a non-empty 2D array grid of 0’s and 1’s, and island is a group of 1’s (representing land) connected 4-directionary (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.\n  Find the maximum area of an island in the given 2D array. (if there is no island, the maximum area is 0)\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  def solve(grid): def dfs(grid, i, j): grid[i][j] = 0 result = 0 for di, dj in ((-1,0),(1,0),(0,1),(0,-1)): if 0 \u003c= i + di \u003c len(grid) and 0 \u003c= j + dj \u003c len(grid[0]) and grid[i+di][j+dj]: result += dfs(grid, i+di, j+dj) return result + 1 result = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j]: result = max(result, dfs(grid, i, j)) return result   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  def solve_bfs(grid): m, n = len(grid), len(grid[0]) result = 0 for i in range(m): for j in range(n): if grid[i][j]: count = 0 queue = deque([(i, j)]) grid[i][j] = 0 while queue: x, y = queue.popleft() count += 1 for dx, dy in ((-1,0), (1,0), (0,1), (0,-1)): if 0 \u003c= x + dx \u003c m and 0 \u003c= y + dy \u003c n and grid[x+dx][y+dy]: grid[x+dx][y+dy] = 0 queue.append((x+dx, y+dy)) result = max(result, count) return result   ","description":"","tags":null,"title":"Island","uri":"/algorithms/ds/depth-first-search/island/"},{"categories":["Algorithms"],"content":"Remove Linked List Elements (LC203)  Remove all elements from a linked list of integers that have value val.\n 1 2 3 4 5 6 7 8  def solve(head, val): it = dummy = ListNode(next=head) while head: if head.val != val: it = head else: it.next = head.next return dummy.next   Remove Duplicates from Sorted List (LC83)  Given the head of a sorted linked list, delete all duplicates such that each element appears only once. Return *the linked list sorted as well.\n 1 2 3 4 5 6 7 8  def solve(head): c = head while c and c.next: if c.val == c.next.val: c.next = c.next.next else: c = c.next return head   Remove Duplicates from Sorted List II (LC82)  Given the head of a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list. Return the linked list sorted as well.\n 1 2 3 4 5 6 7 8 9 10 11  def solve(head): c = dummy = ListNode(next=head) while head: while head.next and head.val == head.next.val: head = head.next if c.next == head: c.next = head.next else: c = c.next head = head.next return dummy.next   Remove Nth Node From End of List (LC19)  Given the head of a linked list, remove the nth node from the end of the list and return its head. Constraints: 0 \u003c n \u003c length of the list\n 1 2 3 4 5 6 7 8 9  def solve(head, n): c = dummy = ListNode(next = head) while head: if n \u003c= 0: c = c.next head = head.next n -= 1 c.next = c.next.next return dummy.next   ","description":"","tags":["Linked List"],"title":"Remove Elements","uri":"/algorithms/ds/linked-list/remove-elements/"},{"categories":null,"content":"Binary Tree Data Structure of the Node 1 2 3 4 5  class TreeNode: def __init__(self, val, left = None, right = None): self.val = val self.left = left self.right = right   Traversal 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78  def preorder(root): return [root.val] + preorder(root.left) + preorder(root.right) if root else [] def inorder(root): return inorder(root.left) + [root.val] + inorder(root.right) if root else [] def postorder(root): return postorder(root.left) + postorder(root.right) + [root.val] if root else [] def preorder(root: TreeNode) -\u003e List[int]: result = [] stack = [] while stack or root: if root: result.append(root.val) stack.append(root) root = root.left else: root = stack.pop().right return result def inorder(root: TreeNode) -\u003e List[int]: result = [] stack = [] while stack or root: if root: stack.append(root) root = root.left else: result.append(stack[-1].val) root = stack.pop().right return result def postorder(root: TreeNode) -\u003e List[int]: result = [] stack = [] while stack or root: if root: result.append(root.val) stack.append(root) root = root.right else: root = stack.pop().left return result[::-1] def bfs(root): if not root: return [] result = [] queue = Deque([root]) while queue: node = queue.popleft() result.append(node.val) # action point if node.left: queue.append(node.left) if node.right: queue.append(node.right) return result def level_order(root): if not root: return [] result = [] level = [root] while level: result.append(node.val for node in level) level = [kid for node in level for kid in (node.left, node.right) if kid] return result def insert_to_sorted_circular(head: ListNode, val: int) -\u003e ListNode: it = head while it and it.val \u003c it.next.val: it = it.next while it.next.val \u003e val: it = it.next it.next = ListNode(val, next=it.next) return head   ","description":"","tags":null,"title":"Binary Tree","uri":"/algorithms/ds/binary-tree/binary-tree/"},{"categories":["Algorithms","LeetCode"],"content":"[Problem, LC] Given an integer array instructions, you are asked to create a sorted array from the elements in instructions. You start with an empty container nums. For each element from left to right in instructions, insert it into nums. The cost of each insertion is the minimum of the following:\n The number of elements currently in nums that are strictly less than instructions[i] The number of elements currently in nums that are strictly greater than instructions[i]  For example, if inserting element 3 into nums = [1,2,3,5], the cost of insertion is min(2,1) (elements 1 and 2 are less than 3, element 5 is greater than 3) and nums will become [1,2,3,3,5].\nSolution 1 2 3 4 5 6 7 8  def create_sorted_array(instructions: List[int]) -\u003e int: result = 0 nums = [] for i, x in enumerate(instructions): left, right = bisect_left(nums, x), bisect_right(nums, x) result += min(left, i - right) nums[left:left] = [x] return result % (10**9 + 7)   1 2 3 4 5 6 7 8  def create_sorted_array(instructions: List[int]) -\u003e int: result = 0 nums = [] for i, x enumerate(instructions): left, right = nums.bisect_left(x), nums.bisect_right(x) result += min(left, i-right) nums.add(x) return result   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  class BIT: def __init__(self, n: int): self.n = n self.tree = [0 for _ in range(n+1)] def update(self, i: int, delta: int) -\u003e None: while i \u003c= self.n: self.tree[i] += delta i += i \u0026 (-i) def query(self, i: int) -\u003e int: prefix = 0 while i: prefix += self.tree[i] i -= i \u0026 (-i) return prefix def create_sorted_array(instructions: List[int]) -\u003e int: bit = BIT(max(instructions)) result = 0 for i, x in enumerate(instructions): left, right = bit.query(x-1), bit.query(x) result += min(left, i-right) bit.update(x, 1) return result   ","description":"","tags":["Binary Search","BIT"],"title":"Create Sorted Array Through Instructions","uri":"/algorithms/2021/01/10/create-sorted-array-through-instructions/"},{"categories":null,"content":"Word Ladder (LC127)  Given two words begin and end, and a dictionary words, return *the length of the shortest transformation sequence from begin to end, such that:\n Only one letter can be changed at a time. Each transformed word must exist in the word list.    Return 0 if there is no such transformation sequenece\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  def solve(begin, end, words): if end not in words: return 0 d = defaultdict(set) n = len(begin) for word in words: for i in range(n): d[word[0:i] + '?' + word[i+1:]].add(word) queue = deque([(begin, 1)]) seen = {begin} while queue: word, depth = queue.popleft() for i in range(n): for w in d[word[0:i] + '?' + word[i+1:]]: if end == w: return depth + 1 if w not in seen: seen.add(w) queue.append((w, depth + 1)) return 0   ","description":"","tags":null,"title":"Breadth First Search","uri":"/algorithms/ds/breadth-first-search/breadth-first-search/"},{"categories":["Algorithms","LeetCode"],"content":"Problem, LC127 A transformation sequence from word beginWord to word endWord using a dictionary wordList is a sequence of words beginWord -\u003e s1 -\u003e s2 -\u003e ... -\u003e sk such that:\n Every adjacent pair of words differs by a single letter Every si for 1 \u003c= i \u003c= k is wordList. Note that beginWord does not need to be in wordList. sk == endWord  Given two words, beginWord and endWord, and a dictionary wordList, return the number of words in the shortest transformation sequence from beginWord to endWord, or 0 if no such sequence exists.\nConstraints:  1 \u003c= beginWord.length \u003c= 10 endWord.length == beginWord.length 1 \u003c= wordList.length \u003c= 5000 wordList[i].length == beginWord.length beginWord, endWord and wordList[i] consist of lowercase English letters. beginWord != endWord All the words in wordList are unique.  Example:  Input: beginWord = “hit”, endWord = “cog”, wordList = [“hot”, “dot”, “dog”, “lot”, “log”, “cog”], Output: 5 Input: beginWord = “hit”, endWord = “cog”, wordList = [“hot”, “dot”, “dog”, “lot”, “log”], Output: 0\n Solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  def ladder_length(words: List[str], begin: str, end: str) -\u003e int: if end not in words: return 0 aux = defaultdict(set) for word in words: for i in range(len(word)): aux[word[:i] + '?' + word[i+1:]].add(word) queue = Deque([(begin, 1)]) seen = {begin} while queue: word, step = queue.popleft() for i in range(len(word)): key = word[:i] + '?' + word[i+1:] for w in aux[key]: if w == end: return step+1 if w not in seen: seen.add(w) queue.append((w, step+1)) return 0   ","description":"","tags":["BFS","Deque","Set"],"title":"Word Ladder","uri":"/algorithms/2021/01/09/word-ladder/"},{"categories":["Algorithms","LeetCode"],"content":"Problem, LC1662 Given two string arrays word1 and word2, return true if the two arrays represent the same string, and false otherwise.\nA string is represented by an array if the array elements concatenated in order forms the string.\nConstraints:  1 \u003c= word1.length, word2.length \u003c= 10^3 1 \u003c= word1[i].length, word2[i].length \u003c= 10^3 1 \u003c= sum(word1[i].length), sum(word2[i].length) \u003c= 10^3 word1[i] and word2[i] consist of lowercase letters.  Example:   Input: word1 = [“a”, “bc”], word2 = [“ab”, “c”], Output: true Input: word1 = [“bc”, “a”], word2 = [“a”, “bc”], Output: false Input: word1 = [“a”, “cb”], word2 = [“a”, “bc”], Output: false   Solution 1 2  def are_string_arrays_equal(word1: List[str], word2: List[str]) -\u003e bool: return ''.join(word1) == ''.join(word2)   ","description":"","tags":["String","Join"],"title":"Check if Two String Arrays Are Equivalent","uri":"/algorithms/2021/01/08/check-if-two-string-arrays-are-equivalent/"},{"categories":["Algorithms","LeetCode"],"content":"Problem, LC3 Given a string s, find the length of the longest substring without repeating characters.\nExample:\n Input: s = “abcabcbb”\" Output: 3\n Solution 1 2 3 4 5 6 7  def longest_distinct_substring(s: str) -\u003e int: result, j, seen = 0, -1, {} for i, c in enumerate(s): j = max(j, seen.get(c, -1)) seen[c] = i result = max(result, i-j) return result   ","description":"","tags":["String","Sliding Window"],"title":"Longest Substring Without Repeating Characters","uri":"/algorithms/2021/01/07/longest-substring-without-repeating-characters/"},{"categories":null,"content":"List Node 1 2 3 4  class ListNode: def __init__(self, val = 0, next = None): self.val = val self.next = next   ","description":"","tags":null,"title":"Linked List","uri":"/algorithms/ds/linked-list/linked-list/"},{"categories":null,"content":"Missing Number(LC268)  Given any array nums containing n distinct numbers in the range[0, n],return the only number in the range that is missing from the array.\n Math 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  def solve_by_math(nums): ans = 0 for i, n in enumerate(nums): ans += i + 1 - n return ans def solve_by_bit(nums): ans = 0 for i, n in enumerate(nums): ans ^= i ^ n return ans def solve_by_set(nums): s = set(nums) for i in range(len(nums)): if i not in s: return i return len(nums) def solve_by_cycle(nums): i = 0 while i \u003c len(nums): j = nums[i] if j \u003c len(nums) and nums[j] != nums[i]: nums[i], nums[j] = nums[i], nums[j] else: i += 1 for i, x in enumerate(nums): if i != x: return i return len(nums)   Kth Missing Positive Number (LC1539)  Given an array nums of positive integers sorted in strictly increasing order, and an integer k. Find the kth positive integer that is missing from this array.\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  def solve_by_bisect(nums, k): start, end = 0, len(nums) while start \u003c end: mid = (start + end) // 2 if nums[mid] - mid - 1 \u003c k: start = mid + 1 else: end = mid return start + k def solve_by_set(nums, k): s = set(nums) for i in range(k + len(nums)): if k == 0: return i + 1 if i + 1 not in s: k -= 1   First Missing Positive (LC41)  Given an unsorted integer array nums, find the smallest missing positive integer.\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14  def solve_by_cycle(nums): n = len(nums) i = 0 while i \u003c n: j = nums[i] - 1 if j \u003c n and nums[i] != nums[j]: nums[i], nums[j] = nums[j], nums[i] else: i += 1 for i, x in enumerate(nums): if i + 1 != x: return i + 1 return len(nums) + 1   ","description":"","tags":null,"title":"Missing Number","uri":"/algorithms/ds/array/missing-number/"},{"categories":["Algorithms","LeetCode"],"content":"Problem, LC1539 Given an array arr of positive integers sorted in a strictly increasing order, and an integer k.\nFind the kth positive integer that is missing from this array.\nExample:\n Input: arr = [2,3,4,7,11], k = 5 Output: 9\n 1 2 3 4 5 6 7 8 9  def find_kth_positive(arr: List[int], k: int) -\u003e int: start, end = 0, len(arr) while start \u003c end: mid = (start + end) // 2 if arr[mid] - mid \u003e k: end = mid else: start = mid + 1 return start + k   ","description":"","tags":["Binary Search"],"title":"Kth Missing Positive Number","uri":"/algorithms/2021/01/06/kth-missing-positive-number/"},{"categories":["Algorithms","LeetCode"],"content":"Problem, LC82 Given the head of a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list. Return *the linked list sorted as well.\nSolution 1 2 3 4 5 6 7 8 9 10 11  def delete_duplicates(head: ListNode) -\u003e ListNode: it = dummy = ListNode(next=head) while head: if head.next and head.next.val == head.val: while head.next and head.val == head.next.val: head = head.next it.next = head.next else: it = it.next head = head.next return dummy.next   ","description":"","tags":["Linked List","Dummy"],"title":"Remove Duplicates From Sorted List II","uri":"/algorithms/2021/01/05/remove-duplicates-from-sorted-list-ii/"},{"categories":["Algorithms","LeetCode"],"content":"Problem Merge two sorted linked lists and return it as a sorted list. The list should be made by splicing together the nodes of the first two lists.\nSolution 1 2 3 4 5 6 7 8 9 10 11 12  def merge_two_sorted_lists(a: ListNode, b: ListNode) -\u003e ListNode: it = dummy = ListNode() while a and b: if a.val \u003c b.val: it.next = a a = a.next else: it.next = b b = b.next it = it.next it.next = a or b return dummy.next   1 2 3 4 5 6 7 8 9 10  def merge_two_sorted_lists(a: ListNode, b: ListNode) -\u003e ListNode: if not a: return b if not b: return a if a.val \u003c b.val: a.next = merge_two_sorted_lists(a.next, b) return a b.next = merge_two_sorted_list(a, b.next) return b   ","description":"","tags":["Linked List","Dummy","DFS"],"title":"Merge Two Sorted Lists","uri":"/algorithms/2021/01/04/merge-two-sorted-lists/"},{"categories":null,"content":"One Edit Distance (bs32)  Given two string s and t determine whether they are one or zero edit distance away. An edit can be described as deleting a character, adding a character, or replacing a character with another character.\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  def solve(s, t): m, n = len(s), len(t) if abs(m - n) \u003e 1: return False if m == n: return sum(x != y for x, y in zip(s, t)) \u003c 2 i = j = k = 0 while k \u003c min(m, n): if s[i] != t[j]: if i != j: return False if m \u003e n: i += 1 else: j += 1 continue i, j, k = i + 1, j + 1, k + 1 return True   Edit Distance (lc72, bs117)  Given two strings s and t, find the minimum edit distance the two. One edit distance is defined as:\n Deleting a character or Inserting a character or Replacing a character.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  def solve(s, t): m, n = len(s) + 1, len(t) + 1 dp = [[0] * n for _ in range(m)] for i in range(m): dp[i][0] = i for j in range(n): dp[0][j] = j for i in range(1, m): for j in range(1, n): dp[i][j] = min( dp[i-1][j] + 1, # delete s[i-1] dp[i][j-1] + 1, # delete t[i-1], that is, adding for s dp[i-1][j-1] + (s[i-1] != t[j-1]) # replace s[i-1] with t[j-1] ) return dp[-1][-1]   ","description":"","tags":null,"title":"Edit Distance","uri":"/algorithms/dynamic-programming/edit-distance/"},{"categories":null,"content":"Longest Increasing Subsequence (lc300)  Given an integer array nums, return the length of the longest strictly increasing subsequence.\nA subsequence is a sequence that can be derived from an array by deleting some or no elements without changing the order of the remaining elements. For example, [3,6,2,7] is a subsequence of the array [0,3,1,6,2,2,7]\n 1 2 3 4 5 6 7 8 9 10  def solve(nums): if not nums: return 0 dp = [1 for _ in nums] for i range(1, len(nums)): for j in range(i): if nums[j] \u003c nums[i]: dp[j] = max(dp[i], 1 + dp[j]) return max(dp)   1 2 3 4 5 6 7 8 9  def solve(nums): dp = [0 for _ in nums] ans = 0 for x in nums: i = bisect_left(dp, x, hi=ans) dp[i] = x if ans == i: ans += 1 return ans   ","description":"","tags":null,"title":"Longest Increasing Subsequence","uri":"/algorithms/dynamic-programming/longest-increasing-subsequence/"},{"categories":null,"content":"Longest Common Subsequence (lc1143)  Given two strings s and t, return the length of their longest common subsequence. A subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters. (eg, “ace” is a subsequence of “abcde” while “aec” is not). A common subsequence of two strings is a subsequence that is common to both strings. If there is no common subsequence, return 0.\n 1 2 3 4 5 6 7 8  def solve_with_dfs(s, t): def dfs(s, t, i, j): if i == j == 0: return 0 if s[i-1] == t[j-1]: return 1 + dfs(s, t, i-1, j-1) return max(dfs(s, t, i-1, j), dfs(s, t, i, j-1)) return dfs(s, t, len(s), len(t))   1 2 3 4 5 6 7 8 9 10 11 12 13 14  def solve_with_dfs_memo(s, t): def dfs(s, t, i, j , memo): if i == j == 0: return 0 if memo[i][j] != -1: return memo[i][j] if s[i-1] == t[j-1]: memo[i][j] = 1 + dfs(s, t, i-1, j-1, memo) return memo[i][j] memo[i][j] = max(dfs(s, t, i-1, j, memo), dfs(s, t, i, j-1, memo)) return memo[i][j] memo = [[0] * len(t) for _ in s] return dfs(s, t, len(s), len(t), memo)   1 2 3 4 5 6 7  def solve(s, t): m, n = len(s) + 1, len(t) + 1 dp = [[0] * n for _ in range(m)] for i in range(1, m): for j in range(1, n): dp[i][j] = 1 + dp[i-1][j-1] if s[i-1] == t[j-1] else max(dp[i-1][j], dp[i][j-1]) return dp[-1][-1]   1 2 3 4 5 6 7 8  def solve(s, t): m, n = len(s) + 1, len(t) + 1 dp = [0] * n for i in range(1, m): prev = 0 for j in range(1, n): dp[j], prev = prev + 1 if s[i-1] == t[j-1] else max(dp[j], dp[j-1]), dp[j] return dp[-1]   ","description":"","tags":null,"title":"Longest Common Subsequence","uri":"/algorithms/dynamic-programming/longest-common-subsequence/"},{"categories":null,"content":"1710. Maximum Units on a Truck (LC1710)  You are assigned to put some amount of boxes onto one truck. You are give a 2D array boxTypes, where boxTypes[i] = [numberOfBoxes[i], numberOfUnitsPerBox[i]] Return the maximum total number of units that can be put on the truck.\n 1 2 3 4 5 6 7 8 9  def solve(boxes, truck): boxes.sort(key=lambda x: -x[1]) ans = 0 for s, t in boxes: if truck \u003c= s: return ans + truck * t ans += pick * t truck -= pick return ans   1711. Count Good Meals (LC1711)  A good meal is a meal that contains exactly two different food items with a sum of deliciousness equal to a power of two.\nYou can pick any two different foods to make a good meal. Given an array of integers deliciousness wher deliciousness[i] is the deliciousness of the ith item of food, return the number of different good meals you can make from this list modulo 10**9+7\nNote that items with different indices are considered different even if they have the sam deliciousness value.\n  Constraints:\n 1 \u003c= deliciousness.length \u003c= 10**5 0 \u003c= deliciousnedd[i] \u003c= 2**20   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  def solve(foods): MOD = 10**9 + 7 SHIFT = 22 counter = Counter(foods) keys = list(counter.keys()) ans = 0 for k in keys: v = counter[k] if k \u003e 0 and k \u0026 (k - 1) == 0: ans += v * (v - 1) // 2 % MOD del counter[k] for i in range(SHIFT): t = (1 \u003c\u003c i) - k if t in counter: ans += v * counter[t] % MOD return ans % MOD   1712. Ways to Split Array Into Three Subarrays (LC1712)  A split of an integer array is good if:\n The array is split into three non-empty contiguous subarrays - named left, mid, right respectively from left to right. The sum of the elements in left is less than or equal to the sum of the elements in mid, and the sum of the elements in mid is less than or equal to the sum of the elements in right.  Given nums, an array of non-negative integers, return the number of good ways to split nums. As the number may be too large, return it modulo 10**9 + 7.\n 1 2 3 4 5 6 7 8 9 10 11 12  def solve(nums): MOD = 10**9 + 7 n = len(nums) prefix = list(accumulate(nums)) ans = 0 for i in range(n - 2): start = bisect_left(prefix, prefix[i] * 2), lo=i+1) end = bisect_right(prefix, (prefix[i] + prefix[-1]) // 2, hi=n-1) if end \u003e start: ans += (end - start) % MOD return ans % MOD   1713. Minimum Operations to Make a Subsequence (LC1713)  You are given an array target that consists of distinct integers and another integer array arr that can have duplicates.\nIn one operation, you can insert any integer at any position in arr. For example, if arr = [1,4,1,2], you can add 3 in the middle and make it [1,4,3,1,2]. Note that you can insert the integer at the very beginning or end of the array.\nReturn the minimum number of operations needed to make target a subsequence of arr.\n 1 2 3 4 5 6 7 8 9 10  def solve(target, arr): nums = {x: i for i, x in enumerate(target)} piles = [] for x in arr: if x in nums: i = bisect_left(piles, nums[x]) if len(piles) == i: piles.append(0) piles[i] = nums[x] return len(target) - len(piles)   ","description":"","tags":null,"title":"Weekly Contest 222","uri":"/algorithms/contest/weekly-contest-222/"},{"categories":["Algorithms","LeetCode"],"content":"Problem, LC526 Suppose you have n integers labeled 1 through n. A permutation of those n integers perm (1-indexed) is considered a beautiful arrangement if for every i (1 \u003c= i \u003c= n), either of the following is true:\n perm[i] is divisible by i. i is divisible by perm[i].  Given an integer n, return the number of the beautiful arrangements that you can construct.\nConstraints: 1 \u003c= n \u003c= 15\nSolution 1 2 3 4 5 6 7 8 9 10 11  def count_arrangement(n: int) -\u003e int: def dfs(remainder, i): if i == 1: return 1 return sum( dfs(remainder - {x}, i-1) for x in remainder if x % i == 0 or i % x == 0 ) return dfs(set(range(1, n+1)), n)   1 2 3 4 5 6 7 8 9 10 11 12  def count_arrangement(n: int) -\u003e int: \"\"\" use bit mask instead of set \"\"\" @cache def dfs(mask, i): if i == 1: return 1 return sum( dfs(mask | (1 \u003c\u003c b), i-1) for b in range(1, 16) if mask \u0026 (1 \u003c\u003c b) == 0 and (b % i == 0 or i % b == 0) ) return dfs(0, n)   ","description":"","tags":["DFS","Bit Mask"],"title":"Beautiful Arrangement","uri":"/algorithms/2021/01/03/beautiful-arrangement/"},{"categories":null,"content":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  class LetterTrieNode: def __init__(self): self.children = [None] * 26 self.word = False class Dict: def __init__(self): self.root = LetterTrieNode() def add(self, word): node = self.root for c in word: i = ord(c) - ord('a') if not node.children[i]: node.children[i] = LetterTrieNode() node = node.children[i] node.word = True def has(self, word): node = self._node(word) return node and node.word def startswith(self, prefix): return self._node(word) is not None def _node(self, word): node = self.root for c in prefix: i = ord(c) - ord('a') node = node.children[i] if not node: return None return node   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  class Trie: def __init__(self): self.__root = {} def add(self, word): node = self.__root for c in word: if c not in node: cur[c] = {} node = node[c] node['$'] = True def has(self, word): node = self.__root for c in prefix: if c not in node: return False node = node[c] return '$' in node def startswith(self, prefix): node = self.__root for c in prefix: if c not in node: return False node = node[c] return True   Map Sum Pairs  Implement the MapSum class:\n MapSum() initializes the MapSum object void insert(String key, int val) inserts the key-val pair into the map. If the key exists, the original value will be overriden to the new one. int sum(String prefix) returns the sum of all the pairs' value whose key starts with the prefix.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  class TrieNode: def __init__(self): self.children = defaultdict(TrieNode) self.val = 0 class MapSum: def __init__(self): self.root = TrieNode() self.seen = defaultdict(int) def insert(self, key, val): delta = val - self.seen[key] self.seen[key] = val node = self.root for c in key: node = node.children[c] node.val += delta def sum(self, prefix): node = self.root for c in prefix: node = node.children.get(c) if not node: return 0 return node.val   ","description":"","tags":null,"title":"Trie","uri":"/algorithms/ds/trie/trie/"},{"categories":["Algorithms","LeetCode"],"content":"Problem LC1379  Given two binary trees original and cloned and given a reference to a node target in the original tree. The cloned tree is a copy of the original tree. Return a reference to the same node in the cloned tree.\n Constraints  What is the range of the number of nodes? [1, 10^4] Are the values of the nodes unique? Yes. Is the target node null? No. Is the original tree null? No.  Code 1 2 3 4 5 6 7 8 9  def find_node_with_dfs(original: TreeNode, cloned: TreeNode, target: TreeNode) -\u003e TreeNode: if not original: return None if original == target: return cloned return ( self.find_node_with_cloned(original.left, cloned.left, target) or self.find_node_with_cloned(original.right, cloned.right, target) )   1 2 3 4 5 6 7 8 9 10 11  def find_node_with_bfs(original: TreeNode, cloned: TreeNode, target: TreeNode) -\u003e TreeNode: level = Deque([(original, cloned)]) while level: original, cloned = level.popleft() if original == target: return cloned if original.left: level.append((original.left, cloned.left)) if original.right: level.append((original.right, cloned.right)) return None   ","description":"","tags":["DFS","BFS"],"title":"Find a Corresponding Node of a Binary Tree in a Clone of That Tree","uri":"/algorithms/2021/01/02/find-a-corresponding-node-of-a-binary-tree-in-a-clone-of-that-tree/"},{"categories":["Algorithms","LeetCode"],"content":"Problem (LC1640) Given an array of distinct integers arr and an array of integer arrays pieces, where the integers in pieces are distinct. Your goal is form arr by concatenating the arrays in pieces in any order. However, you are not allowed to reorder the integers in each array pieces[i].\nReturn true *if it is possible to form the array arr from pieces. Otherwise, return false.\nIntuition Because the arr’s integers and the pieces' integers are distinct, we can sort the integers of the pieces with the index of the arr’s integers. Then we join the sorted array and compare it.\nSolution 1 2 3  def solve(arr: List[int], pieces: List[List[int]]) -\u003e bool: d = {x: i for i, x in enumerate(arr)} return list(chain(*sorted(pieces, key=lambda x: d.get(x[0], 0)))) == arr   ","description":"","tags":["Sort","Map"],"title":"Check Array Formation Through Concatenation","uri":"/algorithms/2021/01/01/check-array-formation-through-concatenation/"},{"categories":["Algorithms","LeetCode"],"content":"Problem, LC658 Given a sorted integer array arr, two integers k and x, return the k closest integers to x in the array. The result should also be sorted in ascending order.\nAn integer a is closer to x than an integer b if:\n |a - x| \u003c |b - x|, or |a - x| == |b - x| and a \u003c b  ###Example:\n  Input: arr = [1,2,3,4,5], k = 4, x = 3 Output: [1,2,3,4]   Solution 1 2 3 4 5 6 7 8 9  def find_closest_elements(arr: List[int], k: int, x: int) -\u003e List[int]: start, end = 0, len(arr) - k while start \u003c end: mid = (start + end) // 2 if x - arr[mid] \u003e arr[mid+k] - x: start = mid + 1 else: end = mid return arr[start: start+k]   ","description":"","tags":["Binary Search"],"title":"Find K Closest Elements","uri":"/algorithms/2021/07/02/find-k-closest-elements/"}]
